{"title":"Bigdecimal精密计算","uid":"ff8b4e7bd08af9ca18a9a619d3b021b3","slug":"Bigdecimal精密计算","date":"2022-07-02T12:13:23.000Z","updated":"2022-07-02T12:14:25.793Z","comments":true,"path":"api/articles/Bigdecimal精密计算.json","keywords":"Java study learn 学习","cover":null,"content":"<h2 id=\"Bigdecimal精密计算\"><a href=\"#Bigdecimal精密计算\" class=\"headerlink\" title=\"Bigdecimal精密计算\"></a>Bigdecimal精密计算</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;由于double和float不是一个精确的数，不合适去做金融类的计算\n&#x2F;&#x2F;在java.math包下提供了一个BigInteger和Bigdecimal去做计算\ndouble a&#x3D;1.0-0.1-0.1-0.1-0.1-0.1;&#x2F;&#x2F;0.5000000000000001 \nSystem.out.println(a);</code></pre>\n\n<h3 id=\"a-概述\"><a href=\"#a-概述\" class=\"headerlink\" title=\"a.概述\"></a>a.概述</h3><p>Java在java.math包中提供的API类BigDecimal，用来对超过16位有效位的数进行精确的运算。双精度浮点型变量double可以处理16位有效数，但在实际应用中，可能需要对更大或者更小的数进行运算和处理。一般情况下，对于那些不需要准确计算精度的数字，我们可以直接使用Float和Double处理，但是Double.valueOf(String) 和Float.valueOf(String)会丢失精度。所以开发中，如果我们需要精确计算的结果，则必须使用BigDecimal类来操作。</p>\n<p> BigDecimal所创建的是对象，故我们不能使用传统的+、-、*、&#x2F;等算术运算符直接对其对象进行数学运算，而必须调用其相对应的方法。方法中的参数也必须是BigDecimal的对象。构造器是类的特殊方法，专门用来创建对象，特别是带有参数的对象。</p>\n<h3 id=\"b-常用构造函数\"><a href=\"#b-常用构造函数\" class=\"headerlink\" title=\"b.常用构造函数\"></a>b.常用构造函数</h3><h4 id=\"1-常用构造函数\"><a href=\"#1-常用构造函数\" class=\"headerlink\" title=\"1.常用构造函数\"></a>1.常用构造函数</h4><ol>\n<li><p>BigDecimal(int)\t\t\t\t\t\t\t</p>\n<p>创建一个具有参数所指定整数值的对象</p>\n</li>\n<li><p>BigDecimal(double)</p>\n<p>创建一个具有参数所指定双精度值的对象</p>\n</li>\n<li><p>BigDecimal(long)</p>\n<p>创建一个具有参数所指定长整数值的对象</p>\n</li>\n<li><p>BigDecimal(String)</p>\n<p>创建一个具有参数所指定以字符串表示的数值的对象</p>\n</li>\n</ol>\n<h4 id=\"2-使用问题分析\"><a href=\"#2-使用问题分析\" class=\"headerlink\" title=\"2.使用问题分析\"></a>2.使用问题分析</h4><p>使用示例：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">BigDecimal a &#x3D;new BigDecimal(0.1);\n        System.out.println(&quot;a values is:&quot;+a);\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        BigDecimal b &#x3D;new BigDecimal(&quot;0.1&quot;);\n        System.out.println(&quot;b values is:&quot;+b);</code></pre>\n\n<p>结果示例：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">a values is:0.1000000000000000055511151231257827021181583404541015625\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nb values is:0.1</code></pre>\n\n<p>原因分析：</p>\n<p>1）参数类型为double的构造方法的结果有一定的不可预知性。有人可能认为在Java中写入newBigDecimal(0.1)所创建的BigDecimal正好等于 0.1（非标度值 1，其标度为 1），但是它实际上等于0.1000000000000000055511151231257827021181583404541015625。这是因为0.1无法准确地表示为 double（或者说对于该情况，不能表示为任何有限长度的二进制小数）。这样，传入到构造方法的值不会正好等于 0.1（虽然表面上等于该值）。</p>\n<p>2）String 构造方法是完全可预知的：写入 newBigDecimal(“0.1”) 将创建一个 BigDecimal，它正好等于预期的 0.1。因此，比较而言， 通常建议优先使用String构造方法。</p>\n<p>3）当double必须用作BigDecimal的源时，请注意，此构造方法提供了一个准确转换；它不提供与以下操作相同的结果：先使用Double.toString(double)方法，然后使用BigDecimal(String)构造方法，将double转换为String。要获取该结果，请使用static valueOf(double)方法。</p>\n<h3 id=\"c-常用方法详解\"><a href=\"#c-常用方法详解\" class=\"headerlink\" title=\"c.常用方法详解\"></a>c.常用方法详解</h3><h4 id=\"1-常用方法\"><a href=\"#1-常用方法\" class=\"headerlink\" title=\"1.常用方法\"></a>1.常用方法</h4><ol>\n<li><p>add(BigDecimal)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</p>\n<p>BigDecimal对象中的值相加，返回BigDecimal对象</p>\n</li>\n<li><p>subtract(BigDecimal)</p>\n<p>BigDecimal对象中的值相减，返回BigDecimal对象</p>\n</li>\n<li><p>multiply(BigDecimal)</p>\n<p>BigDecimal对象中的值相乘，返回BigDecimal对象</p>\n</li>\n<li><p>divide(BigDecimal)</p>\n<p>BigDecimal对象中的值相除，返回BigDecimal对象</p>\n</li>\n<li><p>toString()</p>\n<p>将BigDecimal对象中的值转换成字符串</p>\n</li>\n<li><p>doubleValue()</p>\n<p>将BigDecimal对象中的值转换成双精度数</p>\n</li>\n<li><p>floatValue()</p>\n<p>将BigDecimal对象中的值转换成单精度数</p>\n</li>\n<li><p>longValue()</p>\n<p>将BigDecimal对象中的值转换成长整数</p>\n</li>\n<li><p>intValue()</p>\n<p>将BigDecimal对象中的值转换成整数</p>\n</li>\n<li><p>BigDecimal remainder(BigDecimal divisor)</p>\n<p>求余数，求BigDecimal类型数据除以divisor的余数。</p>\n</li>\n<li><p>BigDecimal max(BigDecimal value)</p>\n<p>最大数，求两个BigDecimal类型数据的最大值。</p>\n</li>\n<li><p>BigDecimal min(BigDecimal value)</p>\n<p>最小数，求两个BigDecimal类型数据的最小值。</p>\n</li>\n<li><p>BigDecimal abs()</p>\n<p>绝对值，求BigDecimal类型数据的绝对值。</p>\n</li>\n<li><p>BigDecimal negate()</p>\n<p>相反数，求BigDecimal类型数据的相反数。</p>\n</li>\n</ol>\n<h4 id=\"2-大小比较\"><a href=\"#2-大小比较\" class=\"headerlink\" title=\"2.大小比较\"></a>2.大小比较</h4><p>java中对BigDecimal比较大小一般用的是bigdemical的compareTo方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int a &#x3D; bigdemical.compareTo(bigdemical2)</code></pre>\n\n<p>返回结果分析：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">a &#x3D; -1,表示bigdemical小于bigdemical2；\na &#x3D; 0,表示bigdemical等于bigdemical2；\na &#x3D; 1,表示bigdemical大于bigdemical2；</code></pre>\n\n<p>举例：a大于等于b</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">new bigdemica(a).compareTo(new bigdemical(b)) &gt;&#x3D; 0</code></pre>\n\n<h3 id=\"d-BigDecimal格式化\"><a href=\"#d-BigDecimal格式化\" class=\"headerlink\" title=\"d.BigDecimal格式化\"></a>d.BigDecimal格式化</h3><p>由于NumberFormat类的format()方法可以使用BigDecimal对象作为其参数，可以利用BigDecimal对超出16位有效数字的货币值，百分值，以及一般数值进行格式化控制。</p>\n<p>以利用BigDecimal对货币和百分比格式化为例。首先，创建BigDecimal对象，进行BigDecimal的算术运算后，分别建立对货币和百分比格式化的引用，最后利用BigDecimal对象作为format()方法的参数，输出其格式化的货币值和百分比。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">NumberFormat currency &#x3D; NumberFormat.getCurrencyInstance(); &#x2F;&#x2F;建立货币格式化引用 \n   NumberFormat percent &#x3D; NumberFormat.getPercentInstance();  &#x2F;&#x2F;建立百分比格式化引用 \n   percent.setMaximumFractionDigits(3); &#x2F;&#x2F;百分比小数点最多3位 \n   \n   BigDecimal loanAmount &#x3D; new BigDecimal(&quot;15000.48&quot;); &#x2F;&#x2F;贷款金额\n   BigDecimal interestRate &#x3D; new BigDecimal(&quot;0.008&quot;); &#x2F;&#x2F;利率   \n   BigDecimal interest &#x3D; loanAmount.multiply(interestRate); &#x2F;&#x2F;相乘\n\n   System.out.println(&quot;贷款金额:\\t&quot; + currency.format(loanAmount)); \n   System.out.println(&quot;利率:\\t&quot; + percent.format(interestRate)); \n   System.out.println(&quot;利息:\\t&quot; + currency.format(interest)); </code></pre>\n\n<p>结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">贷款金额: ￥15,000.48 利率: 0.8% 利息: ￥120.00</code></pre>\n\n<p>BigDecimal格式化保留2为小数，不足则补0：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class NumberFormat &#123;\n\t\n\tpublic static void main(String[] s)&#123;\n\t\tSystem.out.println(formatToNumber(new BigDecimal(&quot;3.435&quot;)));\n\t\tSystem.out.println(formatToNumber(new BigDecimal(0)));\n\t\tSystem.out.println(formatToNumber(new BigDecimal(&quot;0.00&quot;)));\n\t\tSystem.out.println(formatToNumber(new BigDecimal(&quot;0.001&quot;)));\n\t\tSystem.out.println(formatToNumber(new BigDecimal(&quot;0.006&quot;)));\n\t\tSystem.out.println(formatToNumber(new BigDecimal(&quot;0.206&quot;)));\n    &#125;\n\t&#x2F;**\n\t * @desc 1.0~1之间的BigDecimal小数，格式化后失去前面的0,则前面直接加上0。\n\t * 2.传入的参数等于0，则直接返回字符串&quot;0.00&quot;\n\t * 3.大于1的小数，直接格式化返回字符串\n\t * @param obj传入的小数\n\t * @return\n\t *&#x2F;\n\tpublic static String formatToNumber(BigDecimal obj) &#123;\n\t\tDecimalFormat df &#x3D; new DecimalFormat(&quot;#.00&quot;);\n\t\tif(obj.compareTo(BigDecimal.ZERO)&#x3D;&#x3D;0) &#123;\n\t\t\treturn &quot;0.00&quot;;\n\t\t&#125;else if(obj.compareTo(BigDecimal.ZERO)&gt;0&amp;&amp;obj.compareTo(new BigDecimal(1))&lt;0)&#123;\n\t\t\treturn &quot;0&quot;+df.format(obj).toString();\n\t\t&#125;else &#123;\n\t\t\treturn df.format(obj).toString();\n\t\t&#125;\n\t&#125;\n&#125;</code></pre>\n\n<p>结果为：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">3.44\n0.00\n0.00\n0.00\n0.01\n0.21</code></pre>\n\n<h3 id=\"e-BigDecimal常见异常\"><a href=\"#e-BigDecimal常见异常\" class=\"headerlink\" title=\"e.BigDecimal常见异常\"></a>e.BigDecimal常见异常</h3><h4 id=\"除法的时候出现异常\"><a href=\"#除法的时候出现异常\" class=\"headerlink\" title=\"除法的时候出现异常\"></a>除法的时候出现异常</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result</code></pre>\n\n<p><strong>原因分析：</strong></p>\n<p> 通过BigDecimal的divide方法进行除法时当不整除，出现无限循环小数时，就会抛异常：java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result.</p>\n<p><strong>解决方法：</strong></p>\n<p> divide方法设置精确的小数点，如：divide(xxxxx,2)</p>\n<h3 id=\"f-BigDecimal总结\"><a href=\"#f-BigDecimal总结\" class=\"headerlink\" title=\"f.BigDecimal总结\"></a>f.BigDecimal总结</h3><h4 id=\"1-总结\"><a href=\"#1-总结\" class=\"headerlink\" title=\"1.总结\"></a>1.总结</h4><ol>\n<li>在需要精确的小数计算时再使用BigDecimal，BigDecimal的性能比double和float差，在处理庞大，复杂的运算时尤为明显。故一般精度的计算没必要使用BigDecimal。</li>\n<li>尽量使用参数类型为String的构造函数。</li>\n<li>BigDecimal都是不可变的（immutable）的， 在进行每一次四则运算时，都会产生一个新的对象 ，所以在做加减乘除运算时要记得要保存操作后的值。</li>\n</ol>\n<h4 id=\"2-工具类推荐\"><a href=\"#2-工具类推荐\" class=\"headerlink\" title=\"2.工具类推荐\"></a>2.工具类推荐</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.vivo.ars.util;\nimport java.math.BigDecimal;\n\n&#x2F;**\n * 用于高精确处理常用的数学运算\n *&#x2F;\npublic class ArithmeticUtils &#123;\n    &#x2F;&#x2F;默认除法运算精度\n    private static final int DEF_DIV_SCALE &#x3D; 10;\n\n    &#x2F;**\n     * 提供精确的加法运算\n     *\n     * @param v1 被加数\n     * @param v2 加数\n     * @return 两个参数的和\n     *&#x2F;\n\n    public static double add(double v1, double v2) &#123;\n        BigDecimal b1 &#x3D; new BigDecimal(Double.toString(v1));\n        BigDecimal b2 &#x3D; new BigDecimal(Double.toString(v2));\n        return b1.add(b2).doubleValue();\n    &#125;\n\n    &#x2F;**\n     * 提供精确的加法运算\n     *\n     * @param v1 被加数\n     * @param v2 加数\n     * @return 两个参数的和\n     *&#x2F;\n    public static BigDecimal add(String v1, String v2) &#123;\n        BigDecimal b1 &#x3D; new BigDecimal(v1);\n        BigDecimal b2 &#x3D; new BigDecimal(v2);\n        return b1.add(b2);\n    &#125;\n\n    &#x2F;**\n     * 提供精确的加法运算\n     *\n     * @param v1    被加数\n     * @param v2    加数\n     * @param scale 保留scale 位小数\n     * @return 两个参数的和\n     *&#x2F;\n    public static String add(String v1, String v2, int scale) &#123;\n        if (scale &lt; 0) &#123;\n            throw new IllegalArgumentException(\n                    &quot;The scale must be a positive integer or zero&quot;);\n        &#125;\n        BigDecimal b1 &#x3D; new BigDecimal(v1);\n        BigDecimal b2 &#x3D; new BigDecimal(v2);\n        return b1.add(b2).setScale(scale, BigDecimal.ROUND_HALF_UP).toString();\n    &#125;\n\n    &#x2F;**\n     * 提供精确的减法运算\n     *\n     * @param v1 被减数\n     * @param v2 减数\n     * @return 两个参数的差\n     *&#x2F;\n    public static double sub(double v1, double v2) &#123;\n        BigDecimal b1 &#x3D; new BigDecimal(Double.toString(v1));\n        BigDecimal b2 &#x3D; new BigDecimal(Double.toString(v2));\n        return b1.subtract(b2).doubleValue();\n    &#125;\n\n    &#x2F;**\n     * 提供精确的减法运算。\n     *\n     * @param v1 被减数\n     * @param v2 减数\n     * @return 两个参数的差\n     *&#x2F;\n    public static BigDecimal sub(String v1, String v2) &#123;\n        BigDecimal b1 &#x3D; new BigDecimal(v1);\n        BigDecimal b2 &#x3D; new BigDecimal(v2);\n        return b1.subtract(b2);\n    &#125;\n\n    &#x2F;**\n     * 提供精确的减法运算\n     *\n     * @param v1    被减数\n     * @param v2    减数\n     * @param scale 保留scale 位小数\n     * @return 两个参数的差\n     *&#x2F;\n    public static String sub(String v1, String v2, int scale) &#123;\n        if (scale &lt; 0) &#123;\n            throw new IllegalArgumentException(\n                    &quot;The scale must be a positive integer or zero&quot;);\n        &#125;\n        BigDecimal b1 &#x3D; new BigDecimal(v1);\n        BigDecimal b2 &#x3D; new BigDecimal(v2);\n        return b1.subtract(b2).setScale(scale, BigDecimal.ROUND_HALF_UP).toString();\n    &#125;\n\n    &#x2F;**\n     * 提供精确的乘法运算\n     *\n     * @param v1 被乘数\n     * @param v2 乘数\n     * @return 两个参数的积\n     *&#x2F;\n    public static double mul(double v1, double v2) &#123;\n        BigDecimal b1 &#x3D; new BigDecimal(Double.toString(v1));\n        BigDecimal b2 &#x3D; new BigDecimal(Double.toString(v2));\n        return b1.multiply(b2).doubleValue();\n    &#125;\n\n    &#x2F;**\n     * 提供精确的乘法运算\n     *\n     * @param v1 被乘数\n     * @param v2 乘数\n     * @return 两个参数的积\n     *&#x2F;\n    public static BigDecimal mul(String v1, String v2) &#123;\n        BigDecimal b1 &#x3D; new BigDecimal(v1);\n        BigDecimal b2 &#x3D; new BigDecimal(v2);\n        return b1.multiply(b2);\n    &#125;\n\n    &#x2F;**\n     * 提供精确的乘法运算\n     *\n     * @param v1    被乘数\n     * @param v2    乘数\n     * @param scale 保留scale 位小数\n     * @return 两个参数的积\n     *&#x2F;\n    public static double mul(double v1, double v2, int scale) &#123;\n        BigDecimal b1 &#x3D; new BigDecimal(Double.toString(v1));\n        BigDecimal b2 &#x3D; new BigDecimal(Double.toString(v2));\n        return round(b1.multiply(b2).doubleValue(), scale);\n    &#125;\n\n    &#x2F;**\n     * 提供精确的乘法运算\n     *\n     * @param v1    被乘数\n     * @param v2    乘数\n     * @param scale 保留scale 位小数\n     * @return 两个参数的积\n     *&#x2F;\n    public static String mul(String v1, String v2, int scale) &#123;\n        if (scale &lt; 0) &#123;\n            throw new IllegalArgumentException(\n                    &quot;The scale must be a positive integer or zero&quot;);\n        &#125;\n        BigDecimal b1 &#x3D; new BigDecimal(v1);\n        BigDecimal b2 &#x3D; new BigDecimal(v2);\n        return b1.multiply(b2).setScale(scale, BigDecimal.ROUND_HALF_UP).toString();\n    &#125;\n\n    &#x2F;**\n     * 提供（相对）精确的除法运算，当发生除不尽的情况时，精确到\n     * 小数点以后10位，以后的数字四舍五入\n     *\n     * @param v1 被除数\n     * @param v2 除数\n     * @return 两个参数的商\n     *&#x2F;\n\n    public static double div(double v1, double v2) &#123;\n        return div(v1, v2, DEF_DIV_SCALE);\n    &#125;\n\n    &#x2F;**\n     * 提供（相对）精确的除法运算。当发生除不尽的情况时，由scale参数指\n     * 定精度，以后的数字四舍五入\n     *\n     * @param v1    被除数\n     * @param v2    除数\n     * @param scale 表示表示需要精确到小数点以后几位。\n     * @return 两个参数的商\n     *&#x2F;\n    public static double div(double v1, double v2, int scale) &#123;\n        if (scale &lt; 0) &#123;\n            throw new IllegalArgumentException(&quot;The scale must be a positive integer or zero&quot;);\n        &#125;\n        BigDecimal b1 &#x3D; new BigDecimal(Double.toString(v1));\n        BigDecimal b2 &#x3D; new BigDecimal(Double.toString(v2));\n        return b1.divide(b2, scale, BigDecimal.ROUND_HALF_UP).doubleValue();\n    &#125;\n\n    &#x2F;**\n     * 提供（相对）精确的除法运算。当发生除不尽的情况时，由scale参数指\n     * 定精度，以后的数字四舍五入\n     *\n     * @param v1    被除数\n     * @param v2    除数\n     * @param scale 表示需要精确到小数点以后几位\n     * @return 两个参数的商\n     *&#x2F;\n    public static String div(String v1, String v2, int scale) &#123;\n        if (scale &lt; 0) &#123;\n            throw new IllegalArgumentException(&quot;The scale must be a positive integer or zero&quot;);\n        &#125;\n        BigDecimal b1 &#x3D; new BigDecimal(v1);\n        BigDecimal b2 &#x3D; new BigDecimal(v1);\n        return b1.divide(b2, scale, BigDecimal.ROUND_HALF_UP).toString();\n    &#125;\n\n    &#x2F;**\n     * 提供精确的小数位四舍五入处理\n     *\n     * @param v     需要四舍五入的数字\n     * @param scale 小数点后保留几位\n     * @return 四舍五入后的结果\n     *&#x2F;\n    public static double round(double v, int scale) &#123;\n        if (scale &lt; 0) &#123;\n            throw new IllegalArgumentException(&quot;The scale must be a positive integer or zero&quot;);\n        &#125;\n        BigDecimal b &#x3D; new BigDecimal(Double.toString(v));\n        return b.setScale(scale, BigDecimal.ROUND_HALF_UP).doubleValue();\n    &#125;\n\n    &#x2F;**\n     * 提供精确的小数位四舍五入处理\n     *\n     * @param v     需要四舍五入的数字\n     * @param scale 小数点后保留几位\n     * @return 四舍五入后的结果\n     *&#x2F;\n    public static String round(String v, int scale) &#123;\n        if (scale &lt; 0) &#123;\n            throw new IllegalArgumentException(\n                    &quot;The scale must be a positive integer or zero&quot;);\n        &#125;\n        BigDecimal b &#x3D; new BigDecimal(v);\n        return b.setScale(scale, BigDecimal.ROUND_HALF_UP).toString();\n    &#125;\n\n    &#x2F;**\n     * 取余数\n     *\n     * @param v1    被除数\n     * @param v2    除数\n     * @param scale 小数点后保留几位\n     * @return 余数\n     *&#x2F;\n    public static String remainder(String v1, String v2, int scale) &#123;\n        if (scale &lt; 0) &#123;\n            throw new IllegalArgumentException(\n                    &quot;The scale must be a positive integer or zero&quot;);\n        &#125;\n        BigDecimal b1 &#x3D; new BigDecimal(v1);\n        BigDecimal b2 &#x3D; new BigDecimal(v2);\n        return b1.remainder(b2).setScale(scale, BigDecimal.ROUND_HALF_UP).toString();\n    &#125;\n\n    &#x2F;**\n     * 取余数  BigDecimal\n     *\n     * @param v1    被除数\n     * @param v2    除数\n     * @param scale 小数点后保留几位\n     * @return 余数\n     *&#x2F;\n    public static BigDecimal remainder(BigDecimal v1, BigDecimal v2, int scale) &#123;\n        if (scale &lt; 0) &#123;\n            throw new IllegalArgumentException(\n                    &quot;The scale must be a positive integer or zero&quot;);\n        &#125;\n        return v1.remainder(v2).setScale(scale, BigDecimal.ROUND_HALF_UP);\n    &#125;\n\n    &#x2F;**\n     * 比较大小\n     *\n     * @param v1 被比较数\n     * @param v2 比较数\n     * @return 如果v1 大于v2 则 返回true 否则false\n     *&#x2F;\n    public static boolean compare(String v1, String v2) &#123;\n        BigDecimal b1 &#x3D; new BigDecimal(v1);\n        BigDecimal b2 &#x3D; new BigDecimal(v2);\n        int bj &#x3D; b1.compareTo(b2);\n        boolean res;\n        if (bj &gt; 0)\n            res &#x3D; true;\n        else\n            res &#x3D; false;\n        return res;\n    &#125;\n&#125;</code></pre>\n\n","text":"Bigdecimal精密计算&#x2F;&#x2F;由于double和float不是一个精确的数，不合适去做金融类的计算 &#x2F;&#x2F;在java.math包下提供了一个BigInteger和Bigdecimal去做计算 double a&#x3D;1.0-0.1-0....","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"JavaSE","slug":"JavaSE","count":8,"path":"api/categories/JavaSE.json"}],"tags":[{"name":"Java","slug":"Java","count":8,"path":"api/tags/Java.json"},{"name":"变量","slug":"变量","count":2,"path":"api/tags/变量.json"},{"name":"Bigdecimal","slug":"Bigdecimal","count":1,"path":"api/tags/Bigdecimal.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Bigdecimal%E7%B2%BE%E5%AF%86%E8%AE%A1%E7%AE%97\"><span class=\"toc-text\">Bigdecimal精密计算</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#a-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">a.概述</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#b-%E5%B8%B8%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">b.常用构造函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%B8%B8%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">1.常用构造函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90\"><span class=\"toc-text\">2.使用问题分析</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#c-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3\"><span class=\"toc-text\">c.常用方法详解</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">1.常用方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%A4%A7%E5%B0%8F%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">2.大小比较</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#d-BigDecimal%E6%A0%BC%E5%BC%8F%E5%8C%96\"><span class=\"toc-text\">d.BigDecimal格式化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#e-BigDecimal%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">e.BigDecimal常见异常</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%99%A4%E6%B3%95%E7%9A%84%E6%97%B6%E5%80%99%E5%87%BA%E7%8E%B0%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">除法的时候出现异常</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#f-BigDecimal%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">f.BigDecimal总结</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">1.总结</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%8E%A8%E8%8D%90\"><span class=\"toc-text\">2.工具类推荐</span></a></li></ol></li></ol></li></ol>","author":{"name":"星桜","slug":"blog-author","avatar":"/images/avatar.png","link":"/","description":"学习Java中","socials":{"github":"https://github.com/umrlll","twitter":"https://twitter.com/Smile_Amber234","stackoverflow":"","wechat":"","qq":"tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=1414018493&website=www.oicqzone.com","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/24956413"}}}},"mapped":true,"prev_post":{"title":"流程控制语句","uid":"7689509bc540e79b176cff8111263e2f","slug":"流程控制语句","date":"2022-07-02T12:16:06.000Z","updated":"2022-07-02T12:17:40.913Z","comments":true,"path":"api/articles/流程控制语句.json","keywords":"Java study learn 学习","cover":null,"text":"选择结构用于选择和判断 A.if结构a.简单ifint money&#x3D;10; if(money&gt;100)&#123; System.out.println(&quot;买兰博基尼&quot;); &#125; int money&#x3D;10; if(money&...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[{"name":"JavaSE","slug":"JavaSE","count":8,"path":"api/categories/JavaSE.json"}],"tags":[{"name":"Java","slug":"Java","count":8,"path":"api/tags/Java.json"},{"name":"基础","slug":"基础","count":3,"path":"api/tags/基础.json"},{"name":"流程控制语句","slug":"流程控制语句","count":1,"path":"api/tags/流程控制语句.json"}],"author":{"name":"星桜","slug":"blog-author","avatar":"/images/avatar.png","link":"/","description":"学习Java中","socials":{"github":"https://github.com/umrlll","twitter":"https://twitter.com/Smile_Amber234","stackoverflow":"","wechat":"","qq":"tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=1414018493&website=www.oicqzone.com","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/24956413"}}}},"feature":true},"next_post":{"title":"Java变量","uid":"79af7de75153f420d37fd8766e7c54b8","slug":"Java变量","date":"2022-07-02T12:02:56.000Z","updated":"2022-07-02T12:14:03.669Z","comments":true,"path":"api/articles/Java变量.json","keywords":"Java study learn 学习","cover":[],"text":"A.定义存储在内存中的值并且能够发生改变，数据需要放在内存中才可以进行计算。变量本质是计算机内存中代表一个”可操作的存储空间“，位置是确定的，但里面的值是不确定的可以改变。通过变量名来访问该对应的存储的内存空间里面的值（变量名存储的是这个数据存在内存的地址）从而操作这个内存存储的...","link":"","photos":[],"count_time":{"symbolsCount":"8k","symbolsTime":"7 mins."},"categories":[{"name":"JavaSE","slug":"JavaSE","count":8,"path":"api/categories/JavaSE.json"}],"tags":[{"name":"Java","slug":"Java","count":8,"path":"api/tags/Java.json"},{"name":"变量","slug":"变量","count":2,"path":"api/tags/变量.json"}],"author":{"name":"星桜","slug":"blog-author","avatar":"/images/avatar.png","link":"/","description":"学习Java中","socials":{"github":"https://github.com/umrlll","twitter":"https://twitter.com/Smile_Amber234","stackoverflow":"","wechat":"","qq":"tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=1414018493&website=www.oicqzone.com","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/24956413"}}}}}}