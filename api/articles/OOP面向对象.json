{"title":"OOP面向对象","uid":"a8b9f6886e1afb1f46e24c344f2e7621","slug":"OOP面向对象","date":"2022-07-02T12:18:54.000Z","updated":"2022-07-02T12:27:34.477Z","comments":true,"path":"api/articles/OOP面向对象.json","keywords":null,"cover":null,"content":"<h1 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h1><h2 id=\"A-基本概念\"><a href=\"#A-基本概念\" class=\"headerlink\" title=\"A.基本概念\"></a>A.基本概念</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>面向对象思想将客观世界中的事物描述为对象，并通过抽象思维方法将需要解决的实际问题分解成人们易于理解的对象模型，然后通过这些对象模型来构建应用程序的功能</p>\n<p>面向对象的一些概念</p>\n<p>类、对象、继承、封装、多态等</p></blockquote>\n<p><font color=\"red\">Object Oriented Programming 面向对象编程，是java编程思想中最重要的编程思想！</font></p>\n<p>在OOP之前我们是面向过程的：</p>\n<p>面向过程编程：把一个项目在一个类中从上到下去编写代码，把一个事件分成每一步去执行，比如C语言</p>\n<p>面向过程的弊端：</p>\n<pre class=\"line-numbers language-jav\" data-language=\"jav\"><code class=\"language-jav\">1.代码都在一个类文件中，自上而下执行，代码的耦合度非常高，后期的扩展功能和维护的成本很高 \n2.代码自上而下执行，代码的复用性不高，不能提高开发效率</code></pre>\n\n<h2 id=\"B-对象的概念\"><a href=\"#B-对象的概念\" class=\"headerlink\" title=\"B.对象的概念\"></a>B.对象的概念</h2><p>​        所谓对象就是真实世界中的实体，对象与实体是一一对应的，也就是说现实世界中每一个实体都是一个对象，它是一种具体的概念。</p>\n<p>对象有以下特点：</p>\n<ul>\n<li>对象具有属性和行为。</li>\n<li>对象具有变化的状态。</li>\n<li>对象具有唯一性。</li>\n<li>对象都是某个类别的实例。</li>\n<li>一切皆为对象，真实世界中的所有事物都可以视为对象。</li>\n</ul>\n<h3 id=\"a-类和对象\"><a href=\"#a-类和对象\" class=\"headerlink\" title=\"a.类和对象\"></a>a.类和对象</h3><p>​\t\t在面向对象中，类和对象是最基本、最重要的组成单元。类实际上是表示一个客观世界某类群体的一些基本特征抽象。对象就是表示一个个具体的东西。所以说类是对象的抽象，对象是类的具体。</p>\n<p><font color=\"red\">类是概念模型，定义对象的所有特性和所需的操作，对象是真实的模型，是一个具体的实体。</font></p>\n<p>类是描述了一组有相同特性（属性）和相同行为（方法）的一组对象的集合。</p>\n<p>对象或实体所拥有的特征在类中表示时称为类的属性。例如，每个人都具有姓名、年龄和体重，这是所有人共有的特征。但是每一个对象的属性值又各不相同，例如，小明和小红都具有体重这个属性，但是他们的体重值是不同的。</p>\n<p>对象执行的操作称为类的方法。比如，“人”这个对象都具有的行为是“吃饭”，因此，吃饭就是“人”类的一个方法。</p>\n<p>类是实体对象的概念模型，因此通常是笼统的、不具体的。</p>\n<p>类是构造面向对象程序的基本单位，是抽取了同类对象的共同属性和方法所形成的对象或实体的“模板”。而对象是现实世界中实体的描述，对象要创建才存在，有了对象才能对对象进行操作。类是对象的模板，对象是类的实例。</p>\n<p>​\t\t<font color=\"red\">类：类是一种分类，一个类别，一个模板，它描述一类对象的行为和状态，是一组具有相同特性（属性）与行为（方法）的事物集合</font><br>​\t\t<font color=\"red\">对象：是一个个性的产物，是一个个体的特征，是类的一个实例，有状态和行为</font></p>\n<p><strong>类和对象的关系？</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>类里面有属性和方法，如果你要去调用该类的属性和方法，首相需要创建对象，通过对象可以重复的调用该类中的属性和方法，私有的除外。</p>\n<p>对象能调用到什么属性和方法取决于这个对象属于哪个类(取决于该对象的类型)</p>\n<p>优势：代码重用，提高开发效率</p></blockquote>\n<h3 id=\"b-类的定义\"><a href=\"#b-类的定义\" class=\"headerlink\" title=\"b.类的定义\"></a>b.类的定义</h3><pre><code>      &lt;font color=&quot;red&quot;&gt;类是 [Java](http://c.biancheng.net/java/) 中的一种重要的引用数据类型，也是组成 Java 程序的基本要素，因为所有的 Java 程序都是基于类的。&lt;/font&gt;\n</code></pre>\n<p>在 Java 中定义一个类，需要使用 class 关键字、一个自定义的类名和一对表示程序体的大括号。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">[public][abstract|final]class&lt;class_name&gt;[extends&lt;class_name&gt;][implements&lt;interface_name&gt;] &#123;\n    &#x2F;&#x2F; 定义属性部分\n    &lt;property_type&gt;&lt;property1&gt;;\n    &lt;property_type&gt;&lt;property2&gt;;\n    &lt;property_type&gt;&lt;property3&gt;;\n    …\n    &#x2F;&#x2F; 定义方法部分\n    function1();\n    function2();\n    function3();\n    …\n&#125;</code></pre>\n\n<p>提示：上述语法中，中括号“[]”中的部分表示可以省略，竖线“|”表示“或关系”，例如 abstract|final，说明可以使用 abstract 或 final 关键字，但是两个关键字不能同时出现。</p>\n<p>上述语法中各关键字的描述如下。</p>\n<ul>\n<li><code>public</code>：表示“共有”的意思。如果使用 public 修饰，则可以被其他类和程序访问。每个 Java 程序的主类都必须是 public 类，作为公共工具供其他类和程序使用的类应定义为 public 类。</li>\n<li><code>abstract</code>：如果类被 abstract 修饰，则该类为抽象类，抽象类不能被实例化，但抽象类中可以有抽象方法（使用 abstract 修饰的方法）和具体方法（没有使用 abstract 修饰的方法）。继承该抽象类的所有子类都必须实现该抽象类中的所有抽象方法（除非子类也是抽象类）。</li>\n<li><code>final</code>：如果类被 final 修饰，则不允许被继承。</li>\n<li><code>class</code>：声明类的关键字。</li>\n<li><code>class_name</code>：类的名称。</li>\n<li><code>extends</code>：表示继承其他类。</li>\n<li><code>implements</code>：表示实现某些接口。</li>\n<li><code>property_type</code>：表示成员变量的类型。</li>\n<li><code>property</code>：表示成员变量名称。</li>\n<li><code>function()</code>：表示成员方法名称。</li>\n</ul>\n<p>Java 类名的命名规则：</p>\n<ol>\n<li>类名应该以下划线（_）或字母开头，最好以字母开头。</li>\n<li>第一个字母最好大写，如果类名由多个单词组成，则每个单词的首字母最好都大写。</li>\n<li>类名不能为 Java 中的关键字，例如 boolean、this、int 等。</li>\n<li>类名不能包含任何嵌入的空格或点号以及除了下划线（_）和美元符号（$）字符之外的特殊字符。</li>\n</ol>\n<p>创建一个新的类，就是创建一个新的数据类型。实例化一个类，就是得到类的一个对象。因此，对象就是一组变量和相关方法的集合，其中变量表明对象的状态和属性，方法表明对象所具有的行为。定义一个类的步骤如下所述。</p>\n<p>(1) 声明类。编写类的最外层框架，声明一个名称为 Person 的类。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Person &#123;\n    &#x2F;&#x2F; 类的主体\n&#125;</code></pre>\n\n<p>(2) 编写类的属性。类中的数据和方法统称为类成员。其中，类的属性就是类的数据成员。通过在类的主体中定义变量来描述类所具有的特征（属性），这里声明的变量称为类的成员变量。</p>\n<p>(3) 编写类的方法。类的方法描述了类所具有的行为，是类的方法成员。可以简单地把方法理解为独立完成某个功能的单元模块。</p>\n<p>下面来定义一个简单的 Person 类。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Person &#123;\n    private String name;    &#x2F;&#x2F; 姓名\n    private int age;    &#x2F;&#x2F; 年龄\n    public void tell() &#123;   \n        &#x2F;&#x2F; 定义说话的方法\n        System.out.println(name+&quot;今年&quot;+age+&quot;岁！&quot;);\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"c-类的属性\"><a href=\"#c-类的属性\" class=\"headerlink\" title=\"c.类的属性\"></a>c.类的属性</h3><p>在 <a href=\"http://c.biancheng.net/java/\">Java</a> 中类的成员变量定义了类的属性。例如，一个学生类中一般需要有姓名、性别和年龄等属性，这时就需要定义姓名、性别和年龄 3 个属性。声明成员变量的语法如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">[public|protected|private][static][final]&lt;type&gt;&lt;variable_name&gt;</code></pre>\n\n<p>各参数的含义如下。</p>\n<ul>\n<li>public、protected、private：用于表示成员变量的访问权限。</li>\n<li>static：表示该成员变量为类变量，也称为静态变量。</li>\n<li>final：表示将该成员变量声明为常量，其值无法更改。</li>\n<li>type：表示变量的类型。</li>\n<li>variable_name：表示变量名称。</li>\n</ul>\n<p><font color=\"red\">可以在声明成员变量的同时对其进行初始化，如果声明成员变量时没有对其初始化，则系统会使用默认值初始化成员变量。</font></p>\n<p>初始化的默认值如下：</p>\n<ul>\n<li>整数型（byte、short、int 和 long）的基本类型变量的默认值为 0。</li>\n<li>单精度浮点型（float）的基本类型变量的默认值为 0.0f。</li>\n<li>双精度浮点型（double）的基本类型变量的默认值为 0.0d。</li>\n<li>字符型（char）的基本类型变量的默认值为 “\\u0000”。</li>\n<li>布尔型的基本类型变量的默认值为 false。</li>\n<li>数组引用类型的变量的默认值为 null。如果创建了数组变量的实例，但没有显式地为每个元素赋值，则数组中的元素初始化值采用数组数据类型对应的默认值。</li>\n</ul>\n<p>定义类的成员变量的示例如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Student &#123;\n    public String name;    &#x2F;&#x2F; 姓名\n    final int sex &#x3D; 0;    &#x2F;&#x2F; 性别：0表示女孩，1表示男孩\n    private int age;    &#x2F;&#x2F; 年龄\n&#125;</code></pre>\n\n<h3 id=\"d-成员方法\"><a href=\"#d-成员方法\" class=\"headerlink\" title=\"d.成员方法\"></a>d.成员方法</h3><p>声明成员方法可以定义类的行为，行为表示一个对象能够做的事情或者能够从一个对象取得的信息。类的各种功能操作都是用方法来实现的，属性只不过提供了相应的数据。一个完整的方法通常包括方法名称、方法主体、方法参数和方法返回值类型，成员方法一旦被定义，便可以在程序中多次调用，提高了编程效率。声明成员方法的语法格式如下：</p>\n<pre class=\"line-numbers language-jav\" data-language=\"jav\"><code class=\"language-jav\">public class Test &#123;\n    [public|private|protected][static]&lt;void|return_type&gt;&lt;method_name&gt;([paramList]) &#123;\n        &#x2F;&#x2F; 方法体\n    &#125;\n&#125;</code></pre>\n\n<p>注意：上述语法中，中括号“[]”中的部分表示可以省略，竖线“|”表示“或”，例如 public|private，说明可以使用 public 或 private 关键字，但是两个关键字不能同时出现。</p>\n<p>上述代码中一个方法包含 4 部分：方法的返回值、方法名称、方法的参数和方法体。其中 retum_type 是方法返回值的数据类型，数据类型可以是原始的数据类型，即常用的 8 种数据类型，也可以是一个引用数据类型，如一个类、接口和数组等。</p>\n<p>除了这些，一个方法还可以没有返回值，即返回类型为 void，像 main() 方法。method_name 表示自定义的方法名称，方法的名称首先要遵循标识符的命名约定，除此之外，方法的名称第一个单词的第一个字母是小写，第二单词的第一个字母是大写，依此类推。</p>\n<p>paramList 表示参数列表，这些变量都要有自己的数据类型，可以是原始数据类型，也可以是复杂数据类型，一个方法主要依靠参数来传递消息。方法主体是方法中执行功能操作的语句。其他各修饰符的含义如下。</p>\n<ul>\n<li>public、private、protected：表示成员方法的访问权限。</li>\n<li>static：表示限定该成员方法为静态方法。</li>\n<li>final：表示限定该成员方法不能被重写或重载。</li>\n<li>abstract：表示限定该成员方法为抽象方法。抽象方法不提供具体的实现，并且所属类型必须为抽象类。</li>\n</ul>\n<h4 id=\"1-成员方法的返回值\"><a href=\"#1-成员方法的返回值\" class=\"headerlink\" title=\"1.成员方法的返回值\"></a>1.成员方法的返回值</h4><p>若方法有返回值，则在方法体中用 return 语句指明要返回的值，其格式如下所示。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">return 表达式\n   或\n   return (表达式)</code></pre>\n\n<p>其中，表达式可以是常量、变量、对象等。表达式的数据类型必须与声明成员方法时给出的返回值类型一致。</p>\n<h4 id=\"2-形参、实参及成员方法的调用\"><a href=\"#2-形参、实参及成员方法的调用\" class=\"headerlink\" title=\"2.形参、实参及成员方法的调用\"></a>2.形参、实参及成员方法的调用</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">methodName(&#123;paramList&#125;)</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public int returnMin(int m,int n) &#123;\n    return Math.min(m,n);    &#x2F;&#x2F; m和n是形参\n&#125;\npublic static void main(String[] args) &#123;\n    int x &#x3D; 50;\n    int y &#x3D; 100;\n    Test t &#x3D; new Test();\n    int i &#x3D; t.returnMin(x,y);    &#x2F;&#x2F; x和y是实参\n    System.out.println(i);\n&#125;</code></pre>\n\n<p>方法的形参和实参具有以下特点：</p>\n<ul>\n<li>形参变量只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元。因此，形参只有在方法内部有效，方法调用结束返回主调方法后则不能再使用该形参变量。</li>\n<li>实参可以是常量、变量、表达式、方法等，无论实参是何种类型的量，在进行方法调用时，它们都必须具有确定的值，以便把这些值传送给形参。因此应预先用赋值、输入等办法使实参获得确定值。</li>\n<li>实参和形参在数量、类型和顺序上应严格一致，否则会发生“类型不匹配” 的错误。</li>\n<li>方法调用中发生的数据传送是单向的，即只能把实参的值传送绐形参，而不能把形参的值反向地传送给实参。因此在方法调用过程中，形参的值发生改变，而实参中的值不会变化。</li>\n</ul>\n<p>在调用成员方法时应注意以下 4 点：</p>\n<ol>\n<li>对无参成员方法来说，是没有实际参数列表的（即没有 paramList），但方法名后的括号不能省略。</li>\n<li>对带参数的成员方法来说，实参的个数、顺序以及它们的数据类型必须与形式参数的个数、顺序以及它们的数据类型保持一致，各个实参间用逗号分隔。实参名与形参名可以相同，也可以不同。</li>\n<li>实参也可以是表达式，此时一定要注意使表达式的数据类型与形参的数据类型相同，或者使表达式的类型按 <a href=\"http://c.biancheng.net/java/\">Java</a> 类型转换规则达到形参指明的数据类型。</li>\n<li>实参变量对形参变量的数据传递是“值传递”，即只能由实参传递给形参，而不能由形参传递给实参。程序中执行到调用成员方法时，Java 把实参值复制到一个临时的存储区（栈）中，形参的任何修改都在栈中进行，当退出该成员方法时，Java 自动清除栈中的内容。</li>\n</ol>\n<h4 id=\"3-方法中的局部变量\"><a href=\"#3-方法中的局部变量\" class=\"headerlink\" title=\"3.方法中的局部变量\"></a>3.方法中的局部变量</h4><p>在方法体内可以定义本方法所使用的变量，这种变量是局部变量。它的生存期与作用域是在本方法内，也就是说，局部变量只能在本方法内有效或可见，离开本方法则这些变量将被自动释放。</p>\n<p>在方法体内定义变量时，变量前不能加修饰符。局部变量在使用前必须明确赋值，否则编译时会出错。另外，在一个方法内部，可以在复合语句（把多个语句用括号<code>&#123;&#125;</code>括起来组成的一个语句称复合语句）中定义变量，这些变量只在复合语句中有效。</p>\n<h3 id=\"e-this关键字\"><a href=\"#e-this关键字\" class=\"headerlink\" title=\"e.this关键字\"></a>e.this关键字</h3><p>​\t\tthis 关键字是 <a href=\"http://c.biancheng.net/java/\">Java</a> 常用的关键字，可用于任何实例方法内指向当前对象，也可指向对其调用当前方法的对象，或者在需要当前类型对象引用时使用。</p>\n<p>this的两种使用方法</p>\n<p>1.如果发生局部变量可以成员变量命名冲突时，可以通过this.成员变量名的方式区分实例变量和局部变量</p>\n<p>2.一个构造方法中需要调用同一个类的另一个构造方法，可以通过this()的方式调用，但this()必须要书写在第一行</p>\n<h4 id=\"this-属性名\"><a href=\"#this-属性名\" class=\"headerlink\" title=\"this.属性名\"></a>this.属性名</h4><p>通过this.成员变量名调用隐藏的成员变量</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Teacher &#123;\n    private String name;    &#x2F;&#x2F; 教师名称\n    private double salary;    &#x2F;&#x2F; 工资\n    private int age;    &#x2F;&#x2F; 年龄\n    public Teacher(String name,double salary,int age) &#123;\n    this.name &#x3D; name;    &#x2F;&#x2F; 设置教师名称\n    this.salary &#x3D; salary;    &#x2F;&#x2F; 设置教师工资\n    this.age &#x3D; age;    &#x2F;&#x2F; 设置教师年龄\n    &#125;\n&#125;</code></pre>\n\n<p>this([参数列表])调用本一个类的另外一个构造方法</p>\n<h4 id=\"this-方法名\"><a href=\"#this-方法名\" class=\"headerlink\" title=\"this.方法名\"></a>this.方法名</h4><h3 id=\"f-构造方法\"><a href=\"#f-构造方法\" class=\"headerlink\" title=\"f.构造方法\"></a>f.构造方法</h3><p>构造方法是类的一种特殊方法，用来初始化类的一个新的对象，在创建对象（new 运算符）之后自动调用。<a href=\"http://c.biancheng.net/java/\">Java</a> 中的每个类都有一个默认的构造方法，并且可以有一个以上的构造方法。</p>\n<p>Java 构造方法有以下特点：</p>\n<ul>\n<li>方法名必须与类名相同</li>\n<li>可以有 0 个、1 个或多个参数</li>\n<li>没有任何返回值，包括 void</li>\n<li>默认返回类型就是对象类型本身</li>\n<li>只能与 new 运算符结合使用</li>\n</ul>\n<p>构造方法主要有无参构造方法和有参构造方法两种</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyClass &#123;\n    private int m;    &#x2F;&#x2F; 定义私有变量\n    MyClass() &#123;\n        &#x2F;&#x2F; 定义无参的构造方法\n        m &#x3D; 0;\n    &#125;\n    MyClass(int m) &#123;\n        &#x2F;&#x2F; 定义有参的构造方法\n        this.m &#x3D; m;\n    &#125;\n&#125;</code></pre>\n\n<p>该示例定义了两个构造方法，分别是无参构造方法和有参构造方法。在一个类中定义多个具有不同参数的同名方法，这就是方法的重载。这两个构造方法的名称都与类名相同，均为 MyClass。在实例化该类时可以调用不同的构造方法进行初始化。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">注意：类的构造方法不是要求必须定义的。如果在类中没有定义任何一个构造方法，则 Java 会自动为该类生成一个默认的构造方法。默认的构造方法不包含任何参数，并且方法体为空。如果类中显式地定义了一个或多个构造方法，则 Java 不再提供默认构造方法。</code></pre>\n\n<p>要在不同的条件下使用不同的初始化行为创建类的对象，这时候就需要在一个类中创建多个构造方法。下面通过一个示例来演示构造方法的使用。</p>\n<h3 id=\"g-对象的创建\"><a href=\"#g-对象的创建\" class=\"headerlink\" title=\"g.对象的创建\"></a>g.对象的创建</h3><h4 id=\"1-直接通过对象操作属性赋值\"><a href=\"#1-直接通过对象操作属性赋值\" class=\"headerlink\" title=\"**1.**直接通过对象操作属性赋值\"></a>**1.**直接通过对象操作属性赋值</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Car car1&#x3D;new Car(); \ncar1.brand&#x3D;&quot;大众CC&quot;; \ncar1.color&#x3D;&quot;黑色&quot;; \ncar1.money&#x3D;-30;&#x2F;&#x2F;直接赋值，数据不安全 \ncar1.carNumber&#x3D;&quot;赣Asv999&quot;;\ncar1.carGo();</code></pre>\n\n<h4 id=\"2-通过将属性封装，提高数据的安全性\"><a href=\"#2-通过将属性封装，提高数据的安全性\" class=\"headerlink\" title=\"2.通过将属性封装，提高数据的安全性\"></a>2.通过将属性封装，提高数据的安全性</h4><p>封装的定义：</p>\n<pre class=\"line-numbers language-JAVA\" data-language=\"JAVA\"><code class=\"language-JAVA\">将类中的某些信息(属性或方法)封装在类的内部，不允许外部程序直接访问，而是通过该类提供的方法来实现 对隐藏信息的操作</code></pre>\n\n<p>步骤：1.将成员变量private私有化，将成员变量封装get、set方法分别来获取值和设置值</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private String brand;\n    private String color;\n    private int price;\n    private String numberPlate;\n\n    public String getBrand() &#123;\n        return brand;\n    &#125;\n\n    public void setBrand(String brand) &#123;\n        this.brand &#x3D; brand;\n    &#125;\n\n    public String getColor() &#123;\n        return color;\n    &#125;\n\n    public void setColor(String color) &#123;\n        this.color &#x3D; color;\n    &#125;\n\n    public int getPrice() &#123;\n        return price;\n    &#125;\n\n    public void setPrice(int price) &#123;\n        &#x2F;&#x2F;将业务处理隐藏在方法内部，对象调用的时候无需知道内部具体实现的细节，这就是封装的概念 \n        &#x2F;&#x2F;如果是负数就取用绝对值\n        this.price &#x3D; price;\n    &#125;\n\n    public String getNumberPlate() &#123;\n        return numberPlate;\n    &#125;\n\n    public void setNumberPlate(String numberPlate) &#123;\n        this.numberPlate &#x3D; numberPlate;\n    &#125;\n\n    public void showCarInfo()&#123;\n        System.out.println(&quot;汽车品牌:&quot;+brand+&quot;,汽车颜色&quot;+this.color+&quot;,汽车价格&quot;+this.price+&quot;,车牌号&quot;+this.numberPlate);\n    &#125;\n\n    public Car() &#123;\n    &#125;\n\n    public Car(String brand, String color, int price, String numberPlate) &#123;\n        this.brand &#x3D; brand;\n        this.color &#x3D; color;\n        this.price &#x3D; price;\n        this.numberPlate &#x3D; numberPlate;\n    &#125;</code></pre>\n\n<h4 id=\"3-构造方法初始化对象赋值\"><a href=\"#3-构造方法初始化对象赋值\" class=\"headerlink\" title=\"3.构造方法初始化对象赋值\"></a>3.构造方法初始化对象赋值</h4><pre class=\"line-numbers language-JAVA\" data-language=\"JAVA\"><code class=\"language-JAVA\">&#x2F;&#x2F;通过构造方法创建对象并且初始化对象，而且还可以对业务进行封装，数据更安全！ \npublic Car(String brand, String color, int money, String carNumber) \n&#123; \n    this.brand &#x3D; brand; \n    this.color &#x3D; color; \n    if (money&lt;0) &#123; \n        this.money&#x3D; Math.abs(money); \n    &#125;else &#123; \n        this.money &#x3D; money; \n    &#125;this.carNumber &#x3D; carNumber; \n&#125;</code></pre>\n\n<h3 id=\"h-static关键字\"><a href=\"#h-static关键字\" class=\"headerlink\" title=\"h.static关键字\"></a>h.static关键字</h3><p>在类中，使用 static 修饰符修饰的属性（成员变量）称为静态变量，也可以称为类变量，常量称为静态常量，方法称为静态方法或类方法，它们统称为静态成员，归整个类所有。</p>\n<h4 id=\"静态变量\"><a href=\"#静态变量\" class=\"headerlink\" title=\"静态变量\"></a>静态变量</h4><p>类的成员变量可以分为以下两种：</p>\n<ol>\n<li>静态变量（或称为类变量），指被 static 修饰的成员变量。</li>\n<li>实例变量，指没有被 static 修饰的成员变量</li>\n</ol>\n<p>静态变量与实例变量的区别如下：</p>\n<p>1）静态变量</p>\n<ul>\n<li>运行时，Java 虚拟机只为静态变量分配一次内存，在加载类的过程中完成静态变量的内存分配。</li>\n<li>在类的内部，可以在任何方法内直接访问静态变量。</li>\n<li>在其他类中，可以通过类名访问该类中的静态变量。</li>\n</ul>\n<p>2）实例变量</p>\n<ul>\n<li>每创建一个实例，Java 虚拟机就会为实例变量分配一次内存。</li>\n<li>在类的内部，可以在非静态方法中直接访问实例变量。</li>\n<li>在本类的静态方法或其他类中则需要通过类的实例对象进行访问。</li>\n</ul>\n<p>静态变量在类中的作用如下：</p>\n<ul>\n<li>静态变量可以被类的所有实例共享，因此静态变量可以作为实例之间的共享数据，增加实例之间的交互性。</li>\n<li>如果类的所有实例都包含一个相同的常量属性，则可以把这个属性定义为静态常量类型，从而节省内存空间。例如，在类中定义一个静态常量 PI。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static double PI &#x3D; 3.14159256;</code></pre>\n\n<h4 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h4><p>与成员变量类似，成员方法也可以分为以下两种：</p>\n<ol>\n<li>静态方法（或称为类方法），指被 static 修饰的成员方法。</li>\n<li>实例方法，指没有被 static 修饰的成员方法。</li>\n</ol>\n<p>静态方法与实例方法的区别如下：</p>\n<ul>\n<li>静态方法不需要通过它所属的类的任何实例就可以被调用，因此在静态方法中不能使用 this 关键字，也不能直接访问所属类的实例变量和实例方法，但是可以直接访问所属类的静态变量和静态方法。另外，和 this 关键字一样，super 关键字也与类的特定实例相关，所以在静态方法中也不能使用 super 关键字。</li>\n<li>在实例方法中可以直接访问所属类的静态变量、静态方法、实例变量和实例方法。</li>\n</ul>\n<h3 id=\"i-权限修饰符\"><a href=\"#i-权限修饰符\" class=\"headerlink\" title=\"i.权限修饰符\"></a>i.权限修饰符</h3><p>访问修饰符可以用于修饰属性和方法，用于定义属性和方法的访问权限</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>本类</th>\n<th>本包</th>\n<th>子类</th>\n<th>其他包</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>private(私有的)</td>\n<td>OK</td>\n<td>NO</td>\n<td>NO</td>\n<td>NO</td>\n</tr>\n<tr>\n<td>default(默认不写)</td>\n<td>OK</td>\n<td>OK</td>\n<td>NO</td>\n<td>NO</td>\n</tr>\n<tr>\n<td>protected(受保护的)</td>\n<td>OK</td>\n<td>OK</td>\n<td>OK(有继承关系的其他包也可以用)</td>\n<td>NO</td>\n</tr>\n<tr>\n<td>public(公有的)</td>\n<td>OK</td>\n<td>OK</td>\n<td>OK</td>\n<td>OK</td>\n</tr>\n</tbody></table>\n<p><font color=\"red\">权限从小到大: private&lt;默认不写&lt;protected&lt;public公有的</font></p>\n<h2 id=\"C-特性\"><a href=\"#C-特性\" class=\"headerlink\" title=\"C.特性\"></a>C.特性</h2><h3 id=\"a-继承性\"><a href=\"#a-继承性\" class=\"headerlink\" title=\"a.继承性\"></a>a.继承性</h3><p>程序中的继承性是指子类拥有父类的全部特征和行为，这是类之间的一种关系。Java 只支持单继承。即只能有一个父类，但 Java 可以实现多个接口（接口类似于类，但接口的成员没有执行体。可以防止多继承所引起的冲突问题。</p>\n<p>使用这种层次形的分类方式，是为了将多个类的通用属性和方法提取出来，放在它们的父类中，然后只需要在子类中各自定义自己独有的属性和方法，并以继承的形式在父类中获取它们的通用属性和方法即可。</p>\n<h3 id=\"b-封装性\"><a href=\"#b-封装性\" class=\"headerlink\" title=\"b.封装性\"></a>b.封装性</h3><p>封装是将代码及其处理的数据绑定在一起的一种编程机制，该机制保证了程序和数据都不受外部干扰且不被误用。封装的目的在于保护信息，使用它的主要优点如下。</p>\n<ul>\n<li>保护类中的信息，它可以阻止在外部定义的代码随意访问内部代码和数据。</li>\n<li>隐藏细节信息，一些不需要程序员修改和使用的信息，比如取款机中的键盘，用户只需要知道按哪个键实现什么操作就可以，至于它内部是如何运行的，用户不需要知道。</li>\n<li>有助于建立各个系统之间的松耦合关系，提高系统的独立性。当一个系统的实现方式发生变化时，只要它的接口不变，就不会影响其他系统的使用。例如 U 盘，不管里面的存储方式怎么改变，只要 U 盘上的 USB 接口不变，就不会影响用户的正常操作。</li>\n<li>提高软件的复用率，降低成本。每个系统都是一个相对独立的整体，可以在不同的环境中得到使用。例如，一个 U 盘可以在多台电脑上使用。</li>\n</ul>\n<p>Java 语言的基本封装单位是类。由于类的用途是封装复杂性，所以类的内部有隐藏实现复杂性的机制。Java 提供了私有和公有的访问模式，类的公有接口代表外部的用户应该知道或可以知道的每件东西，私有的方法数据只能通过该类的成员代码来访问，这就可以确保不会发生不希望的事情。</p>\n<h3 id=\"c-多态性\"><a href=\"#c-多态性\" class=\"headerlink\" title=\"c.多态性\"></a>c.多态性</h3><p>面向对象的多态性，即“一个接口，多个方法”。多态性体现在父类中定义的属性和方法被子类继承后，可以具有不同的属性或表现方式。多态性允许一个接口被多个同类使用，弥补了单继承的不足。</p>\n<h1 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h1><h2 id=\"A-定义\"><a href=\"#A-定义\" class=\"headerlink\" title=\"A.定义\"></a>A.定义</h2><pre class=\"line-numbers language-JAVA\" data-language=\"JAVA\"><code class=\"language-JAVA\">把代码逻辑细节用方法封装起来，通过对象能够重复调用方法，实现代码复用，提高工作效率</code></pre>\n\n<h2 id=\"B-方法种类\"><a href=\"#B-方法种类\" class=\"headerlink\" title=\"B.方法种类\"></a>B.方法种类</h2><p>返回值： 有返回值的、无返回值的</p>\n<p>参数：有参的、无参数的</p>\n<pre class=\"line-numbers language-JAVA\" data-language=\"JAVA\"><code class=\"language-JAVA\">1.无返回值无参方法 \n   2.无返回值有参方法 \n   3.有返回值无参方法 \n   4.有返回值有参方法</code></pre>\n\n<h3 id=\"案例1：\"><a href=\"#案例1：\" class=\"headerlink\" title=\"案例1：\"></a>案例1：</h3><pre class=\"line-numbers language-JAVA\" data-language=\"JAVA\"><code class=\"language-JAVA\">public void jisuan() &#123; \n    Scanner input&#x3D;new Scanner(System.in);\n    System.out.print(&quot;请输入语文成绩:&quot;);\n    int yuwen&#x3D;input.nextInt(); \n    System.out.print(&quot;请输入数学成绩:&quot;); \n    int shuxue&#x3D;input.nextInt(); \n    System.out.print(&quot;请输入英语成绩:&quot;); \n    int yingyu&#x3D;input.nextInt(); \n    &#x2F;&#x2F;平均分 \n    int avg&#x3D;(yuwen+shuxue+yingyu)&#x2F;3; \n    System.out.println(&quot;三门课程的平均分是:&quot;+avg); &#125;</code></pre>\n\n<pre class=\"line-numbers language-JAVA\" data-language=\"JAVA\"><code class=\"language-JAVA\">&#x2F;**\n*需求： \n*在测试类调用计算的方法，得到语文、数学、英语的三门课程的平均分 \n*\n*&#x2F; \npublic class Test &#123; \n    public static void main(String[] args) &#123; \n        Admin admin&#x3D;new Admin(); \n        &#x2F;&#x2F;调用无返回值无参数方法 \n        admin.jisuan(); \n    &#125; \n&#125;</code></pre>\n\n<h3 id=\"案例2：\"><a href=\"#案例2：\" class=\"headerlink\" title=\"案例2：\"></a>案例2：</h3><pre class=\"line-numbers language-JAVA\" data-language=\"JAVA\"><code class=\"language-JAVA\">public class Admin &#123; \n    &#x2F;**\n    * 有返回值无参数的方法 \n    * @return \n    *&#x2F; \n    public int jisuan() &#123; \n        Scanner input&#x3D;new Scanner(System.in); \tSystem.out.print(&quot;请输入语文成绩:&quot;); int yuwen&#x3D;input.nextInt(); System.out.print(&quot;请输入数学成绩:&quot;); int shuxue&#x3D;input.nextInt(); System.out.print(&quot;请输入英语成绩:&quot;); int yingyu&#x3D;input.nextInt(); \n        &#x2F;&#x2F;平均分 \n        int avg&#x3D;(yuwen+shuxue+yingyu)&#x2F;3; \n        return avg; \n    &#125; \n&#125;\npublic class Test &#123; \n    static void main(String[] args) &#123; \n        Admin admin&#x3D;new Admin(); \n        &#x2F;&#x2F;调用有返回值无参方法 \n        int avgScore&#x3D; admin.jisuan(); \n        System.out.println(&quot;三门课程的平均分是:&quot;+avgScore); \n    &#125; \n&#125;</code></pre>\n\n<h3 id=\"案例3：\"><a href=\"#案例3：\" class=\"headerlink\" title=\"案例3：\"></a>案例3：</h3><pre class=\"line-numbers language-JAVA\" data-language=\"JAVA\"><code class=\"language-JAVA\">public class Admin &#123; \n    &#x2F;**\n    *\n    * 无返回值有参数方法 \n    * 接受参数的这方叫形式参数(形参) \n    *&#x2F; \n    public void jisuan(int yuwen, int shuxue, int yingyu) &#123;\n        int avg&#x3D;(yuwen+shuxue+yingyu)&#x2F;3; \n        System.out.println(&quot;三门课程的平均分是:&quot;+avg); \n    &#125; \n&#125;\n&#x2F;**\n* 需求： 在测试类调用计算的方法，得到语文、数学、英语的三门课程的平均分 *\n*&#x2F; \npublic class Test &#123;\n    public static void main(String[] args) &#123; \n    \tScanner input &#x3D; new Scanner(System.in); \n    \tSystem.out.print(&quot;请输入语文成绩:&quot;); \n    \tint yuwen &#x3D; input.nextInt(); \n   \t \tSystem.out.print(&quot;请输入数学成绩:&quot;); \n    \tint shuxue &#x3D; input.nextInt(); \n    \tSystem.out.print(&quot;请输入英语成绩:&quot;); \n    \tint yingyu &#x3D; input.nextInt(); \n    \tAdmin admin &#x3D; new Admin(); \n    \t&#x2F;&#x2F;调用无返回值有参方法 \n    \t&#x2F;&#x2F;具体传递值的叫实际参数(实参) \n   \t\tadmin.jisuan(yuwen,shuxue,yingyu);\n        &#125; \n&#125;</code></pre>\n\n<h2 id=\"C-值传递和引用类型传递【重要】\"><a href=\"#C-值传递和引用类型传递【重要】\" class=\"headerlink\" title=\"C.值传递和引用类型传递【重要】\"></a>C.值传递和引用类型传递【重要】</h2><h3 id=\"1-值类型案例\"><a href=\"#1-值类型案例\" class=\"headerlink\" title=\"1.值类型案例\"></a>1.值类型案例</h3><pre class=\"line-numbers language-JAVA\" data-language=\"JAVA\"><code class=\"language-JAVA\">public class Admin &#123; \n    &#x2F;&#x2F;两值交换 \n    public void change(int a, int b) &#123; \n        int c&#x3D;a; a&#x3D;b; b&#x3D;c; \n        System.out.println(&quot;交换：a:&quot;+a+&quot;,b:&quot;+b);\n    &#125; \n&#125;</code></pre>\n\n<pre class=\"line-numbers language-JAVA\" data-language=\"JAVA\"><code class=\"language-JAVA\">&#x2F;**\n*值传递 \n* @author Administrator \n*\n*&#x2F; \npublic class Test &#123; \n    public static void main(String[] args) &#123; \n    int a&#x3D;5; \n    int b&#x3D;10; \n    Admin admin&#x3D;new Admin(); \n    &#x2F;&#x2F;基本数据类型为参数，是值传递，是将值赋值一份给形参，当形参的值发生了改变，实参的值不变 \n    admin.change(a,b);&#x2F;&#x2F; \n    System.out.println(&quot;a:&quot;+a+&quot;,b:&quot;+b);&#x2F;&#x2F;结果5,10 \n&#125;&#125;</code></pre>\n\n<h3 id=\"2-引用类型传递\"><a href=\"#2-引用类型传递\" class=\"headerlink\" title=\"2.引用类型传递\"></a>2.引用类型传递</h3><pre class=\"line-numbers language-JAVA\" data-language=\"JAVA\"><code class=\"language-JAVA\">public class Arrays &#123; \n    &#x2F;**\n    * static修饰的方法叫类方法或者叫静态方法 \n    * 类方法属于类，可以通过类名直接调用，一般工具方法都是这样用比较方便 \n    * @param score \n    *&#x2F; \n    public static void sortByDesc(int[] score) &#123; \n        for (int i &#x3D; 0; i &lt; score.length-1; i++) &#123; \n            for (int j &#x3D; 0; j &lt; score.length-i-1; j++) &#123;\n                if (score[j]&lt;score[j+1]) &#123; \n                    int temp&#x3D;score[j]; \n                    score[j]&#x3D;score[j+1]; \n                    score[j+1]&#x3D;temp; \n                &#125; \n            &#125; \n        &#125; \n    &#125; \n&#125;</code></pre>\n\n<pre class=\"line-numbers language-JAVA\" data-language=\"JAVA\"><code class=\"language-JAVA\">&#x2F;**\n* 引用类型传递值 \n*\n*&#x2F; \npublic class Test &#123; \n    public static void main(String[] args) &#123; \n        int score[]&#x3D; &#123;3,45,6,67,1&#125;;\n        &#x2F;&#x2F; Arrays.sort(score); \n        &#x2F;&#x2F;数组、对象、集合、接口、类都是引用类型！ \n        &#x2F;&#x2F;以数组为实参，是引用类型传递，是将score数组的地址复制了一份给形参 \n        &#x2F;&#x2F;当形参指引到的数组的值发生了改变，因为实参和形参的地址是同一个，所以实参的值也会改变！ \n        Arrays.sortByDesc(score); \n        for (int i : score) &#123; \n            System.out.print(&quot; &quot;+i); \n        &#125;\n    &#125; \n&#125;</code></pre>\n\n<h1 id=\"方法重写和方法重载\"><a href=\"#方法重写和方法重载\" class=\"headerlink\" title=\"方法重写和方法重载\"></a>方法重写和方法重载</h1><h2 id=\"A-方法重载Overload【重要】\"><a href=\"#A-方法重载Overload【重要】\" class=\"headerlink\" title=\"A.方法重载Overload【重要】\"></a>A.方法重载Overload【重要】</h2><pre class=\"line-numbers language-JAVA\" data-language=\"JAVA\"><code class=\"language-JAVA\">在同一个类中，多个方法名相同，但是参数的个数、类型、顺序不同，叫方法重载，与返回类型无关 方法重载各个重名的方法之间没有任何联系，只是叫同一个方法名而已，像构造方法必须和类名一致有时候需 要多个构造方法，所以叫构造方法重载。</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Student &#123; \n    String name;&#x2F;&#x2F;姓名 \n    int age;&#x2F;&#x2F;年龄 \n    char sex;&#x2F;&#x2F;性别 \n    String studentNo;&#x2F;&#x2F;学号 \n    double price;&#x2F;&#x2F;学费 \n    public Student() &#123;&#125; \n    public Student(String name, int age, char sex) &#123; \n        super(); \n        this.name &#x3D; name; \n        this.age &#x3D; age; \n        this.sex &#x3D; sex; \n    &#125;\n    &#x2F;&#x2F;构造方法的常见体现：构造方法重载 \n    public Student(String name, int age, char sex, String studentNo, double price) &#123;\n        this.name &#x3D; name; \n        this.age &#x3D; age; \n        this.sex &#x3D; sex; \n        this.studentNo &#x3D; studentNo;\n        this.price &#x3D; price; \n    &#125;\n    public void study()&#123; \n        System.out.println(&quot;学生学习！&quot;); \n    &#125;\n    &#x2F;&#x2F;在一个类中，多个方法名相同，参数的个数、顺序、类型不同，叫方法重载，与返回类型无关 \n    public void study(String name)&#123; \n        System.out.println(name+&quot;学生学习！&quot;); \n    &#125;\n    public static void main(String[] args) &#123; \n        &#x2F;&#x2F;具体调用本类中哪个方法具体看方法的参数！\n        new Student().study(); \n        new Student().study(&quot;狗剩&quot;);\n        String str&#x3D;&quot;我是江西老表&quot;; &#x2F;&#x2F;字符串截取 \n        String str2&#x3D;str.substring(2); \n        System.out.println(str2); \n        String str3&#x3D;str.substring(2,4); \n        System.out.println(str3);\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"B-方法重写Override【重要】\"><a href=\"#B-方法重写Override【重要】\" class=\"headerlink\" title=\"B.方法重写Override【重要】\"></a>B.方法重写Override【重要】</h2><p><font color=\"red\">注意：我们所有的类都是继承于Object父类，</font>父类也可以叫基类或者超类。子类继承于父类，当子类和父类的方法一致并且内容做了覆盖，叫做方法重写！</p>\n<h3 id=\"1-重写object类的toString方法\"><a href=\"#1-重写object类的toString方法\" class=\"headerlink\" title=\"1.重写object类的toString方法\"></a>1.重写object类的toString方法</h3><pre class=\"line-numbers language-JAVA\" data-language=\"JAVA\"><code class=\"language-JAVA\">public class Student &#123; \n    String name;&#x2F;&#x2F;姓名 \n    int age;&#x2F;&#x2F;年龄 \n    char sex;&#x2F;&#x2F;性别 \n    String studentNo;&#x2F;&#x2F;学号 \n    double price;&#x2F;&#x2F;学费 \n    &#x2F;&#x2F;构造方法的常见体现：构造方法重载 \n    public Student(String name, int age, char sex, String studentNo, double price) &#123;\n        this.name &#x3D; name; \n        this.age &#x3D; age; \n        this.sex &#x3D; sex; \n        this.studentNo &#x3D; studentNo; \n        this.price &#x3D; price; \n    &#125;\n    &#x2F;&#x2F;重写了Object类的toString方法 \n    &#x2F;&#x2F;子类如果和父类方法一致，只是具体实现内容不一样，叫方法重写或者叫方法覆盖 \n    &#x2F;&#x2F;优势：扩展性更强！ \n    @Override \n    public String toString() &#123; \n        return &quot;Student属性:[name&#x3D;&quot; + name + &quot;, age&#x3D;&quot; + age + &quot;, sex&#x3D;&quot; + sex + &quot;, studentNo&#x3D;&quot; + studentNo + &quot;, price&#x3D;&quot; + price + &quot;]&quot;; \n    &#125; \n&#125;</code></pre>\n\n<pre class=\"line-numbers language-JAVA\" data-language=\"JAVA\"><code class=\"language-JAVA\">public class Test &#123; \n    public static void main(String[] args) &#123; \n        Student stu2&#x3D;new Student(&quot;张三&quot;,21,&#39;男&#39;,&quot;S0001&quot;,1000); \n        System.out.println(stu2.toString()); \n    &#125; \n&#125;</code></pre>\n\n<h3 id=\"2-重写Object类的equals方法\"><a href=\"#2-重写Object类的equals方法\" class=\"headerlink\" title=\"2.重写Object类的equals方法\"></a>2.重写Object类的equals方法</h3><pre class=\"line-numbers language-JAVA\" data-language=\"JAVA\"><code class=\"language-JAVA\">public class Teacher &#123; \n    String name;&#x2F;&#x2F;称呼 \n    int code;&#x2F;&#x2F;身份证号码\n    public Teacher(String name, int code) &#123; \n        super(); \n        this.name &#x3D; name; \n        this.code &#x3D; code; \n    &#125;\n    &#x2F;**\n    * 重写Object父类的equals方法，如果编号一致就返回true \n    *&#x2F; \n    @Override \n    public boolean equals(Object obj) &#123; \n        &#x2F;&#x2F;如果两个对象地址一致，返回true \n        if (this&#x3D;&#x3D;obj) &#123; return true; &#125;\n        &#x2F;&#x2F;将父类类型用子类类型接收，需要向下转型 \n        Teacher t&#x3D;(Teacher) obj; \n        if (this.code&#x3D;&#x3D;t.code) \n        &#123; \n            &#x2F;&#x2F;判断两个对象的属性code员工编号一致，那么就返回true \n            return true; \n        &#125;else &#123; return false; &#125; \n    &#125; \n&#125;</code></pre>\n\n<pre class=\"line-numbers language-JAVA\" data-language=\"JAVA\"><code class=\"language-JAVA\">public class Test &#123; \n    public static void main(String[] args) &#123; \n        Teacher teacher1&#x3D;new Teacher(&quot;棋哥&quot;,10001); \n        Teacher teacher2&#x3D;new Teacher(&quot;老彭&quot;,10001);\n &#x2F;&#x2F;System.out.println(teacher1.equals(teacher2));&#x2F;&#x2F;false \n        &#x2F;&#x2F;需求：根据身份证编号来判断这两个对象是同一个人！ \n        &#x2F;&#x2F;Object类的equals方法底层是比较地址，显然不能满足我们的需求，如何解决？-&gt;重写Object的 equals方法 \n        System.out.println(teacher1.equals(teacher2));&#x2F;&#x2F;true \n    &#125; \n   \n&#125;</code></pre>\n\n","feature":true,"text":"面向对象A.基本概念 面向对象思想将客观世界中的事物描述为对象，并通过抽象思维方法将需要解决的实际问题分解成人们易于理解的对象模型，然后通过这些对象模型来构建应用程序的功能 面向对象的一些概念 类、对象、继承、封装、多态等 Object Oriented Programming ...","link":"","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"18 mins."},"categories":[{"name":"JavaSE","slug":"JavaSE","count":8,"path":"api/categories/JavaSE.json"}],"tags":[{"name":"Java","slug":"Java","count":8,"path":"api/tags/Java.json"},{"name":"基础","slug":"基础","count":3,"path":"api/tags/基础.json"},{"name":"OOP","slug":"OOP","count":1,"path":"api/tags/OOP.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">面向对象</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#A-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">A.基本概念</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#B-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">B.对象的概念</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#a-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">a.类和对象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#b-%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">b.类的定义</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#c-%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">c.类的属性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#d-%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">d.成员方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC\"><span class=\"toc-text\">1.成员方法的返回值</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%BD%A2%E5%8F%82%E3%80%81%E5%AE%9E%E5%8F%82%E5%8F%8A%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">2.形参、实参及成员方法的调用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">3.方法中的局部变量</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#e-this%E5%85%B3%E9%94%AE%E5%AD%97\"><span class=\"toc-text\">e.this关键字</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#this-%E5%B1%9E%E6%80%A7%E5%90%8D\"><span class=\"toc-text\">this.属性名</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#this-%E6%96%B9%E6%B3%95%E5%90%8D\"><span class=\"toc-text\">this.方法名</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#f-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">f.构造方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#g-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">g.对象的创建</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E7%9B%B4%E6%8E%A5%E9%80%9A%E8%BF%87%E5%AF%B9%E8%B1%A1%E6%93%8D%E4%BD%9C%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC\"><span class=\"toc-text\">**1.**直接通过对象操作属性赋值</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E9%80%9A%E8%BF%87%E5%B0%86%E5%B1%9E%E6%80%A7%E5%B0%81%E8%A3%85%EF%BC%8C%E6%8F%90%E9%AB%98%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7\"><span class=\"toc-text\">2.通过将属性封装，提高数据的安全性</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AF%B9%E8%B1%A1%E8%B5%8B%E5%80%BC\"><span class=\"toc-text\">3.构造方法初始化对象赋值</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#h-static%E5%85%B3%E9%94%AE%E5%AD%97\"><span class=\"toc-text\">h.static关键字</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">静态变量</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">静态方法</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#i-%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6\"><span class=\"toc-text\">i.权限修饰符</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#C-%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">C.特性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#a-%E7%BB%A7%E6%89%BF%E6%80%A7\"><span class=\"toc-text\">a.继承性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#b-%E5%B0%81%E8%A3%85%E6%80%A7\"><span class=\"toc-text\">b.封装性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#c-%E5%A4%9A%E6%80%81%E6%80%A7\"><span class=\"toc-text\">c.多态性</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#A-%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">A.定义</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#B-%E6%96%B9%E6%B3%95%E7%A7%8D%E7%B1%BB\"><span class=\"toc-text\">B.方法种类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A1%88%E4%BE%8B1%EF%BC%9A\"><span class=\"toc-text\">案例1：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A1%88%E4%BE%8B2%EF%BC%9A\"><span class=\"toc-text\">案例2：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A1%88%E4%BE%8B3%EF%BC%9A\"><span class=\"toc-text\">案例3：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#C-%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BC%A0%E9%80%92%E3%80%90%E9%87%8D%E8%A6%81%E3%80%91\"><span class=\"toc-text\">C.值传递和引用类型传递【重要】</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%80%BC%E7%B1%BB%E5%9E%8B%E6%A1%88%E4%BE%8B\"><span class=\"toc-text\">1.值类型案例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BC%A0%E9%80%92\"><span class=\"toc-text\">2.引用类型传递</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E5%92%8C%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD\"><span class=\"toc-text\">方法重写和方法重载</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#A-%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BDOverload%E3%80%90%E9%87%8D%E8%A6%81%E3%80%91\"><span class=\"toc-text\">A.方法重载Overload【重要】</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#B-%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99Override%E3%80%90%E9%87%8D%E8%A6%81%E3%80%91\"><span class=\"toc-text\">B.方法重写Override【重要】</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E9%87%8D%E5%86%99object%E7%B1%BB%E7%9A%84toString%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">1.重写object类的toString方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E9%87%8D%E5%86%99Object%E7%B1%BB%E7%9A%84equals%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">2.重写Object类的equals方法</span></a></li></ol></li></ol></li></ol>","author":{"name":"星桜","slug":"blog-author","avatar":"/images/avatar.png","link":"/","description":"学习Java中","socials":{"github":"https://github.com/umrlll","twitter":"https://twitter.com/Smile_Amber234","stackoverflow":"","wechat":"","qq":"tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=1414018493&website=www.oicqzone.com","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/24956413"}}}},"mapped":true,"prev_post":{"title":"数组","uid":"e16187d7a3c490f96b788338bdd79d24","slug":"数组","date":"2022-07-02T12:24:10.000Z","updated":"2022-07-02T12:25:01.082Z","comments":true,"path":"api/articles/数组.json","keywords":null,"cover":[],"text":"数组A.声明数组首先必须声明数组变量，才能在程序中使用数组。 dataType[] arrayRefVar; &#x2F;&#x2F; 首选的方法 或 dataType arrayRefVar[]; &#x2F;&#x2F; 效果相同，但不是首选方法 B.创建数组Java 语言使...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"JavaSE","slug":"JavaSE","count":8,"path":"api/categories/JavaSE.json"}],"tags":[{"name":"Java","slug":"Java","count":8,"path":"api/tags/Java.json"},{"name":"基础","slug":"基础","count":3,"path":"api/tags/基础.json"},{"name":"数组","slug":"数组","count":1,"path":"api/tags/数组.json"}],"author":{"name":"星桜","slug":"blog-author","avatar":"/images/avatar.png","link":"/","description":"学习Java中","socials":{"github":"https://github.com/umrlll","twitter":"https://twitter.com/Smile_Amber234","stackoverflow":"","wechat":"","qq":"tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=1414018493&website=www.oicqzone.com","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/24956413"}}}},"feature":true},"next_post":{"title":"流程控制语句","uid":"7689509bc540e79b176cff8111263e2f","slug":"流程控制语句","date":"2022-07-02T12:16:06.000Z","updated":"2022-07-02T12:17:40.913Z","comments":true,"path":"api/articles/流程控制语句.json","keywords":null,"cover":null,"text":"选择结构用于选择和判断 A.if结构a.简单ifint money&#x3D;10; if(money&gt;100)&#123; System.out.println(&quot;买兰博基尼&quot;); &#125; int money&#x3D;10; if(money&...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[{"name":"JavaSE","slug":"JavaSE","count":8,"path":"api/categories/JavaSE.json"}],"tags":[{"name":"Java","slug":"Java","count":8,"path":"api/tags/Java.json"},{"name":"基础","slug":"基础","count":3,"path":"api/tags/基础.json"},{"name":"流程控制语句","slug":"流程控制语句","count":1,"path":"api/tags/流程控制语句.json"}],"author":{"name":"星桜","slug":"blog-author","avatar":"/images/avatar.png","link":"/","description":"学习Java中","socials":{"github":"https://github.com/umrlll","twitter":"https://twitter.com/Smile_Amber234","stackoverflow":"","wechat":"","qq":"tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=1414018493&website=www.oicqzone.com","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/24956413"}}}},"feature":true}}