<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://umrlll.github.io/atom.xml" rel="self"/>
  
  <link href="https://umrlll.github.io/"/>
  <updated>2022-07-02T04:53:17.098Z</updated>
  <id>https://umrlll.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Jetbrains Intellij IDEA 安装</title>
    <link href="https://umrlll.github.io/post/Jetbrains-Intellij-IDEA-%E5%AE%89%E8%A3%85/"/>
    <id>https://umrlll.github.io/post/Jetbrains-Intellij-IDEA-%E5%AE%89%E8%A3%85/</id>
    <published>2022-07-02T02:36:07.000Z</published>
    <updated>2022-07-02T04:53:17.098Z</updated>
    
    <content type="html"><![CDATA[<p>IDEA安装</p><p>IDEA 全称 IntelliJ IDEA，是Java编程语言开发的集成环境(IDE)。IntelliJ在业界被公认为最好的Java开发工具，尤其在智能代码助手、代码自动提示、重构、J2EE支持、各类版本工具(git、svn等)、JUnit、CVS整合、代码分析、 创新的GUI设计等方面的功能可以说是超常的。IDEA是JetBrains公司的产品，这家公司总部位于捷克，著名的JetBrains全家桶有：PHPStorm、PyCharm、RubyMine、WebStorm、AppCode等，本文介绍的激活IDEA教程适用于大部分的JetBrains全家桶。</p><span id="more"></span><h1 id="A-前言"><a href="#A-前言" class="headerlink" title="A.前言"></a>A.前言</h1><p>目前市面上常用的集成开发环境(IDE)有：</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>1.eclipse 免费 官网推荐 解压版</p><p>2.myeclipse 插件版，可以生成很多功能，付费，现在用的几乎很少</p><p>3.IntelliJ IDEA 智能提示很强大，付费</p></blockquote><p>目前市面上eclipse2020和intelliJ IDEA 市场占有率各占一半，前期学习用eclipse，后期框架用IntelliJ IDEA</p><h1 id="B-安装ToolBox"><a href="#B-安装ToolBox" class="headerlink" title="B.安装ToolBox"></a>B.安装ToolBox</h1><p>​技术和软件的更新速度日益加快，通过 Toolbox 可以轻松完成工具更新迭代：同时维护同一个工具的不同版本，在需要的情况下还可以完成软件的回退</p><p>​Toolbox 可以轻松维护工具版本，可以轻松完成安装和卸载操作。Toolbox同时支持 EAP 版本（ Early Access Program，公测版 ），如果你想尝试一下新的功能，可以试试。 </p><p>​Toolbox 集中显示你编辑过的项目，并且按照你的喜好进行了排序。如果安装了多个 IDE 版本，可以选择用哪个版本 IDE 打开项目。即使，你仅仅安装了一个版本的 IDE，Toolbox打开项目的操作也很方便。</p><p><img src="/post/Jetbrains-Intellij-IDEA-%E5%AE%89%E8%A3%85/tu1.png"></p><p>使用 ToolBox App 更新 IntelliJ Idea ，当然不仅仅可以更新 Idea ，所有 Jet Brains 旗下的软件都可以通过 ToolBox 进行安装和更新。</p><p><img src="/post/Jetbrains-Intellij-IDEA-%E5%AE%89%E8%A3%85/tu2.png"></p><p><img src="/post/Jetbrains-Intellij-IDEA-%E5%AE%89%E8%A3%85/tu3.png"></p><p><img src="/post/Jetbrains-Intellij-IDEA-%E5%AE%89%E8%A3%85/tu4.png"></p><p>默认安装位置是c盘</p><p>切换存放地址方法：修改设置中的安装地址即可更改</p><p><img src="/post/Jetbrains-Intellij-IDEA-%E5%AE%89%E8%A3%85/tu5.png"></p><p><img src="/post/Jetbrains-Intellij-IDEA-%E5%AE%89%E8%A3%85/tu6.png"></p><h1 id="C-安装IDEA"><a href="#C-安装IDEA" class="headerlink" title="C.安装IDEA"></a>C.安装IDEA</h1><p>在ToolBox中点击安装即可，如图可更换其他版本</p><p><img src="/post/Jetbrains-Intellij-IDEA-%E5%AE%89%E8%A3%85/tu7.png"></p><h1 id="D-破解"><a href="#D-破解" class="headerlink" title="D.破解"></a>D.破解</h1><p><font color="red">破解版仅供学习使用<font></p><h2 id="1-下载"><a href="#1-下载" class="headerlink" title="1.下载"></a>1.下载</h2><p>下载原生的文件</p><p><img src="/post/Jetbrains-Intellij-IDEA-%E5%AE%89%E8%A3%85/tu8.png"></p><p><img src="/post/Jetbrains-Intellij-IDEA-%E5%AE%89%E8%A3%85/tu9.png"></p><p>解压后放到想放的位置，我的位置为<code>C:\Users\Spz2519\Documents</code></p><p><img src="/post/Jetbrains-Intellij-IDEA-%E5%AE%89%E8%A3%85/tu12.png"></p><h2 id="2-激活码获取"><a href="#2-激活码获取" class="headerlink" title="2.激活码获取"></a>2.激活码获取</h2><p><a href="https://3.jetbra.in/">https://3.jetbra.in/</a></p><p><img src="/post/Jetbrains-Intellij-IDEA-%E5%AE%89%E8%A3%85/tu10.png"></p><p>下载修改好的文件</p><p><img src="/post/Jetbrains-Intellij-IDEA-%E5%AE%89%E8%A3%85/tu11.png"></p><p>替换文件</p><p><img src="/post/Jetbrains-Intellij-IDEA-%E5%AE%89%E8%A3%85/tu13.png"></p><h2 id="3-修改vmoptions文件"><a href="#3-修改vmoptions文件" class="headerlink" title="3.修改vmoptions文件"></a>3.修改vmoptions文件</h2><p><img src="/post/Jetbrains-Intellij-IDEA-%E5%AE%89%E8%A3%85/tu14.png"></p><p><img src="/post/Jetbrains-Intellij-IDEA-%E5%AE%89%E8%A3%85/tu15.png"></p><p><img src="/post/Jetbrains-Intellij-IDEA-%E5%AE%89%E8%A3%85/tu16.png"></p><p><code>-javaagent:\path\ja-netfilter\ja-netfilter.jar</code></p><p><code>--add-opens=java.base/jdk.internal.org.objectweb.asm=ALL-UNNAMED</code><br><code>--add-opens=java.base/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED</code></p><h2 id="4-激活"><a href="#4-激活" class="headerlink" title="4.激活"></a>4.激活</h2><p>获取激活码</p><p><img src="/post/Jetbrains-Intellij-IDEA-%E5%AE%89%E8%A3%85/tu17.png"></p><p><img src="/post/Jetbrains-Intellij-IDEA-%E5%AE%89%E8%A3%85/tu18.png"></p><p>至此，idea破解完成</p><h1 id="E-关于正版"><a href="#E-关于正版" class="headerlink" title="E.关于正版"></a>E.关于正版</h1><p>有几种方法可以获取免费的正版IntelliJ IDEA license</p><p>官方提供了6种免费申请授权的方式</p><h2 id="1-学生和教师免费"><a href="#1-学生和教师免费" class="headerlink" title="1.学生和教师免费"></a>1.学生和教师免费</h2><p>学生和教师（高中、大学）可以免费使用所有 JetBrains IDEs，仅限在学校或者在家中，个人非商业使用。</p><p>申请入口：<a href="http://www.jetbrains.com/shop/eform/students">www.jetbrains.com/shop/eform/students</a></p><p><img src="/post/Jetbrains-Intellij-IDEA-%E5%AE%89%E8%A3%85/tu19.png"></p><p>这个是教育身份，通过教育邮箱认证非常方便，还可以使用学生证、官方证明文件、Github 认证申请</p><p>使用时间：一年，如果还是学生身份，还可以续期。</p><h2 id="2-教育机构免费"><a href="#2-教育机构免费" class="headerlink" title="2.教育机构免费"></a>2.教育机构免费</h2><p>大学、学院、学校和非商业教育机构可以有资格获得免费许可，只限于在教室和计算机实验室中安装所有 JetBrains 工具并使用，仅限用于教育目的。</p><p>说白了，就是只能在教室使用，不能个人和商业使用。</p><p><a href="http://www.jetbrains.com/shop/eform/classroom/faculty">www.jetbrains.com/shop/eform/classroom/faculty</a></p><p><img src="/post/Jetbrains-Intellij-IDEA-%E5%AE%89%E8%A3%85/tu20.png"></p><p>这个申请下来是一年的，可以续期。</p><h2 id="3-培训机构免费"><a href="#3-培训机构免费" class="headerlink" title="3.培训机构免费"></a>3.培训机构免费</h2><p>在申请限制中说的很明白，只能申请一款并且使用时间是 6 个月，过期后会有 25%折扣，这个限制条件相对来说就有点严格了</p><p>申请入口：<a href="http://www.jetbrains.com/shop/eform/classroom/faculty">www.jetbrains.com/shop/eform/classroom/faculty</a></p><h2 id="4-通过开源项目免费申请"><a href="#4-通过开源项目免费申请" class="headerlink" title="4.通过开源项目免费申请"></a>4.通过开源项目免费申请</h2><p>在 <a href="https://www.jetbrains.com/community/opensource/">https://www.jetbrains.com/community/opensource/</a> ，IDEA有一个开源免费协议。简单翻译一下</p><h3 id="申请条款"><a href="#申请条款" class="headerlink" title="申请条款"></a>申请条款</h3><ul><li>您必须是项目负责人或常规提交者。</li><li>您的OS项目符合 开源定义[1] 。</li><li>您的操作系统项目可能不提供付费赞助，或从商业公司或组织（非政府组织，教育，研究或政府）获得资金。您不得为您的操作系统项目提供任何付费支持，咨询或培训服务，也不得分发您的操作系统软件的付费版本。获得该项目工作报酬的贡献者不符合资格。</li><li>您的OS项目正在积极开发至少3个月。</li><li>您的OS项目社区处于活动状态。</li><li>您定期发布更新的版本。</li></ul><h3 id="许可条款"><a href="#许可条款" class="headerlink" title="许可条款"></a>许可条款</h3><ul><li>许可证提供1年，并允许在1年内免费升级软件的所有新版本。</li><li>如果您的项目仍满足要求，可根据要求提供许可证续订。</li><li>一个许可证可以安装在任意数量的计算机上，但不能在两个或更多计算机上同时使用。</li><li>许可证仅提供给核心团队开发人员。</li></ul><h3 id="许可限制"><a href="#许可限制" class="headerlink" title="许可限制"></a>许可限制</h3><ul><li>许可证仅可用于非商业OS开发。请考虑购买单独的许可证以处理商业项目。</li><li>该软件的使用仅限于许可用户，无权将软件转让给任何第三方。</li></ul><p>有关完整的详细信息，请查看开源项目[2]的许可协议[3]</p><p>申请免费使用</p><h3 id="申请门槛"><a href="#申请门槛" class="headerlink" title="申请门槛"></a>申请门槛</h3><p>从协议不难看出，你只需在GitHub上准备一个维护超过3个月的项目开源项目，就可以免费使用IDEA 1年了，1年到期后，可以按照此步骤再申请一次。</p><p>这是一个良好的闭环：</p><ul><li>有开源项目，所以能申请免费使用IDEA；</li><li>有了IDEA神器，又可以更好地维护开源项目……</li></ul><p>申请<br>到 <a href="https://www.jetbrains.com/shop/eform/opensource?product=ALL">https://www.jetbrains.com/shop/eform/opensource?product=ALL</a> 即可提交申请。</p><h2 id="5-大神免费"><a href="#5-大神免费" class="headerlink" title="5.大神免费"></a>5.大神免费</h2><p><img src="/post/Jetbrains-Intellij-IDEA-%E5%AE%89%E8%A3%85/tu21.png"></p><p>出现在上面的名单种的人可以免费使用</p><p>申请入口：<a href="http://www.jetbrains.com/shop/eform/devrecognition">www.jetbrains.com/shop/eform/devrecognition</a></p><h2 id="6-社区-x2F-组织免费"><a href="#6-社区-x2F-组织免费" class="headerlink" title="6.社区&#x2F;组织免费"></a>6.社区&#x2F;组织免费</h2><p>活跃社区&#x2F;组织的组织者可以获得 JetBrains 产品的免费许可证，根据活动举办的频次，每 1~3 个月发放一次许可证，个数也是有限制的。</p><ul><li>30-50 人参加&#x2F;每次活动：1 个免费许可证；</li><li>50-100 人参加&#x2F;每次活动：2 个免费许可证；</li><li>100+ 人参加&#x2F;每次活动：3 个免费许可证；</li></ul><p>申请入口：<a href="http://www.jetbrains.com/shop/eform/community/">www.jetbrains.com/shop/eform/community/</a></p><h1 id="F-关于付费"><a href="#F-关于付费" class="headerlink" title="F.关于付费"></a>F.关于付费</h1><p><strong>IntelliJ IDEA只要订阅满一年，就能获取在订阅结束日期12个月前版本的永久授权</strong></p><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><ul><li>连续订阅不满12个月，无法获取永久授权</li></ul><p><img src="/post/Jetbrains-Intellij-IDEA-%E5%AE%89%E8%A3%85/tu22.png"></p><ul><li>连续订阅刚好12个月，获得<strong>订阅开始时的版本</strong>的永久授权</li></ul><p><img src="/post/Jetbrains-Intellij-IDEA-%E5%AE%89%E8%A3%85/tu23.png"></p><ul><li><p>订阅了 12 个月，但想获得比订阅时更新的软件版本，可通过月订阅增加时长，获得更新的软件版本的永久授权</p><p>比如你订阅时软件版本是 v1，订阅一年到期了，但这时 v2 已经发布了，你想获得 v2 的永久授权，你可以使用月订阅，再订阅几个月，使 订阅结束日期减 12 个月 的时间刚好在 v2 发布的时间。那月订阅取消后，就可以获得 v2 的永久授权了</p></li></ul><p><img src="/post/Jetbrains-Intellij-IDEA-%E5%AE%89%E8%A3%85/tu24.png"></p><ul><li>订阅超过12个月，获得订阅结束日期减12个月的时间所发布版本的永久授权</li></ul><p><img src="/post/Jetbrains-Intellij-IDEA-%E5%AE%89%E8%A3%85/tu25.png"></p><h2 id="IntelliJ-IDEA的订阅选项"><a href="#IntelliJ-IDEA的订阅选项" class="headerlink" title="IntelliJ IDEA的订阅选项"></a>IntelliJ IDEA的订阅选项</h2><p>如果你们公司没买，作为开发者一般使用“个人订阅”。（<strong>个人订阅是可以用作“一般商业用途”的</strong>，也就是说可以在公司里开发商业软件）</p><p><img src="/post/Jetbrains-Intellij-IDEA-%E5%AE%89%E8%A3%85/tu26.png"></p><h2 id="价格"><a href="#价格" class="headerlink" title="价格"></a>价格</h2><p>可以选择只订阅单个软件（如IntelliJ IDEA、PyCharm），也可以订阅全套15个软件（如果要用到至少2个软件，全套比较划算）。</p><p>订阅价格每年价格都不一样，第一年是原价（如IDEA，按现在汇率折合人民币¥990+），第二年是8折（¥790+）、第三年起是6折（¥590+）</p><p><img src="/post/Jetbrains-Intellij-IDEA-%E5%AE%89%E8%A3%85/tu27.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;IDEA安装&lt;/p&gt;
&lt;p&gt;IDEA 全称 IntelliJ IDEA，是Java编程语言开发的集成环境(IDE)。IntelliJ在业界被公认为最好的Java开发工具，尤其在智能代码助手、代码自动提示、重构、J2EE支持、各类版本工具(git、svn等)、JUnit、CVS整合、代码分析、 创新的GUI设计等方面的功能可以说是超常的。IDEA是JetBrains公司的产品，这家公司总部位于捷克，著名的JetBrains全家桶有：PHPStorm、PyCharm、RubyMine、WebStorm、AppCode等，本文介绍的激活IDEA教程适用于大部分的JetBrains全家桶。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://umrlll.github.io/categories/Java/"/>
    
    
    <category term="开发工具" scheme="https://umrlll.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    <category term="环境" scheme="https://umrlll.github.io/tags/%E7%8E%AF%E5%A2%83/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://umrlll.github.io/post/hello-world/"/>
    <id>https://umrlll.github.io/post/hello-world/</id>
    <published>2022-06-29T13:12:11.883Z</published>
    <updated>2022-06-29T13:12:11.883Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MongoDB5.0.9安装</title>
    <link href="https://umrlll.github.io/post/MongoDB5-0-9%E5%AE%89%E8%A3%85/"/>
    <id>https://umrlll.github.io/post/MongoDB5-0-9%E5%AE%89%E8%A3%85/</id>
    <published>2022-06-28T10:11:11.000Z</published>
    <updated>2022-06-29T13:12:11.882Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Aurora主题美化</title>
    <link href="https://umrlll.github.io/post/Aurora%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/"/>
    <id>https://umrlll.github.io/post/Aurora%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/</id>
    <published>2022-06-27T13:55:58.000Z</published>
    <updated>2022-06-29T13:12:11.846Z</updated>
    
    <content type="html"><![CDATA[<p>Aurora主题美化，鼠标移动特效</p><span id="more"></span><h1 id="1-js代码"><a href="#1-js代码" class="headerlink" title="1.js代码"></a>1.js代码</h1><p>路径为：node_modules&#x2F;hexo-theme-aurora&#x2F;source&#x2F;static&#x2F;js&#x2F;</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">(function fairyDustCursor() &#123;    var possibleColors &#x3D; [&quot;#D61C59&quot;, &quot;#E7D84B&quot;, &quot;#1B8798&quot;]  var width &#x3D; window.innerWidth;  var height &#x3D; window.innerHeight;  var cursor &#x3D; &#123;x: width&#x2F;2, y: width&#x2F;2&#125;;  var particles &#x3D; [];    function init() &#123;    bindEvents();    loop();  &#125;    &#x2F;&#x2F; Bind events that are needed  function bindEvents() &#123;    document.addEventListener(&#39;mousemove&#39;, onMouseMove);    document.addEventListener(&#39;touchmove&#39;, onTouchMove);    document.addEventListener(&#39;touchstart&#39;, onTouchMove);        window.addEventListener(&#39;resize&#39;, onWindowResize);  &#125;    function onWindowResize(e) &#123;    width &#x3D; window.innerWidth;    height &#x3D; window.innerHeight;  &#125;    function onTouchMove(e) &#123;    if( e.touches.length &gt; 0 ) &#123;      for( var i &#x3D; 0; i &lt; e.touches.length; i++ ) &#123;        addParticle( e.touches[i].clientX, e.touches[i].clientY, possibleColors[Math.floor(Math.random()*possibleColors.length)]);      &#125;    &#125;  &#125;    function onMouseMove(e) &#123;        cursor.x &#x3D; e.clientX;    cursor.y &#x3D; e.clientY;        addParticle( cursor.x, cursor.y, possibleColors[Math.floor(Math.random()*possibleColors.length)]);  &#125;    function addParticle(x, y, color) &#123;    var particle &#x3D; new Particle();    particle.init(x, y, color);    particles.push(particle);  &#125;    function updateParticles() &#123;        for( var i &#x3D; 0; i &lt; particles.length; i++ ) &#123;      particles[i].update();    &#125;        for( var i &#x3D; particles.length -1; i &gt;&#x3D; 0; i-- ) &#123;      if( particles[i].lifeSpan &lt; 0 ) &#123;        particles[i].die();        particles.splice(i, 1);      &#125;    &#125;      &#125;    function loop() &#123;    requestAnimationFrame(loop);    updateParticles();  &#125;    function Particle() &#123;    this.character &#x3D; &quot;*&quot;;    this.lifeSpan &#x3D; 120; &#x2F;&#x2F;ms    this.initialStyles &#x3D;&#123;      &quot;position&quot;: &quot;fixed&quot;,      &quot;top&quot;: &quot;0&quot;, &#x2F;&#x2F;必须加      &quot;display&quot;: &quot;block&quot;,      &quot;pointerEvents&quot;: &quot;none&quot;,      &quot;z-index&quot;: &quot;10000000&quot;,      &quot;fontSize&quot;: &quot;20px&quot;,      &quot;will-change&quot;: &quot;transform&quot;    &#125;;    this.init &#x3D; function(x, y, color) &#123;      this.velocity &#x3D; &#123;        x:  (Math.random() &lt; 0.5 ? -1 : 1) * (Math.random() &#x2F; 2),        y: 1      &#125;;            this.position &#x3D; &#123;x: x - 10, y: y - 20&#125;;      this.initialStyles.color &#x3D; color;      console.log(color);      this.element &#x3D; document.createElement(&#39;span&#39;);      this.element.innerHTML &#x3D; this.character;      applyProperties(this.element, this.initialStyles);      this.update();            document.body.appendChild(this.element);    &#125;;        this.update &#x3D; function() &#123;      this.position.x +&#x3D; this.velocity.x;      this.position.y +&#x3D; this.velocity.y;      this.lifeSpan--;            this.element.style.transform &#x3D; &quot;translate3d(&quot; + this.position.x + &quot;px,&quot; + this.position.y + &quot;px,0) scale(&quot; + (this.lifeSpan &#x2F; 120) + &quot;)&quot;;    &#125;        this.die &#x3D; function() &#123;      this.element.parentNode.removeChild(this.element);    &#125;      &#125;    function applyProperties( target, properties ) &#123;    for( var key in properties ) &#123;      target.style[ key ] &#x3D; properties[ key ];    &#125;  &#125;    init();&#125;)();</code></pre><h1 id="2-引用js文件"><a href="#2-引用js文件" class="headerlink" title="2.引用js文件"></a>2.引用js文件</h1><p>路径文件：node_modules&#x2F;hexo-theme-aurora&#x2F;layout&#x2F;index.ejs </p><p>放在<code>&lt;body&gt;&lt;/body&gt;</code>标签中</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&#123;% if theme.sakura.enable %&#125;&lt;script async src&#x3D;&quot;&#x2F;static&#x2F;js&#x2F;（前面js代码文件的名字）.js&quot;&gt;&lt;&#x2F;script&gt; &#123;% endif %&#125;</code></pre><h1 id="3-开启配置"><a href="#3-开启配置" class="headerlink" title="3.开启配置"></a>3.开启配置</h1><p>在 _config.aurora.yml 文件中添加</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">sakura:  enable: true</code></pre><p><img src="/post/Aurora%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/tu1.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Aurora主题美化，鼠标移动特效&lt;/p&gt;</summary>
    
    
    
    <category term="hexo" scheme="https://umrlll.github.io/categories/hexo/"/>
    
    
    <category term="Aurora" scheme="https://umrlll.github.io/tags/Aurora/"/>
    
    <category term="美化" scheme="https://umrlll.github.io/tags/%E7%BE%8E%E5%8C%96/"/>
    
    <category term="鼠标" scheme="https://umrlll.github.io/tags/%E9%BC%A0%E6%A0%87/"/>
    
  </entry>
  
  <entry>
    <title>多版本JDK安装环境配置</title>
    <link href="https://umrlll.github.io/post/%E5%A4%9A%E7%89%88%E6%9C%ACJDK%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>https://umrlll.github.io/post/%E5%A4%9A%E7%89%88%E6%9C%ACJDK%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</id>
    <published>2022-06-27T10:45:04.000Z</published>
    <updated>2022-06-29T13:12:11.885Z</updated>
    
    <content type="html"><![CDATA[<p>多版本jdk安装 环境配置</p><span id="more"></span><h1 id="A-LTS版本JDK"><a href="#A-LTS版本JDK" class="headerlink" title="A.LTS版本JDK"></a>A.LTS版本JDK</h1><p>LTS：long-term support</p><p>LTS版本的JDK有3个：分别是jdk8，jdk11，jdk17。</p><table><thead><tr><th align="center">版本</th><th align="center">LTS时间</th></tr></thead><tbody><tr><td align="center">JDK8</td><td align="center">2030年12月</td></tr><tr><td align="center">JDK11</td><td align="center">2026年9月</td></tr><tr><td align="center">JDK17</td><td align="center">2024年9月</td></tr></tbody></table><p>目前在使用jdk8的版本在做学习开发，但是若是想达成了解jdk14或jdk17的新特性或者使用的他们的新特性的目的，就需要可以随时切换版本</p><h2 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h2><p><a href="https://www.oracle.com/java/technologies/downloads/#java8">https://www.oracle.com/java/technologies/downloads/#java8</a></p><p><img src="/post/%E5%A4%9A%E7%89%88%E6%9C%ACJDK%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/tu1.png"></p><h2 id="JDK11"><a href="#JDK11" class="headerlink" title="JDK11"></a>JDK11</h2><p><a href="https://www.oracle.com/java/technologies/downloads/#java11">https://www.oracle.com/java/technologies/downloads/#java11</a></p><p><img src="/post/%E5%A4%9A%E7%89%88%E6%9C%ACJDK%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/tu2.png"></p><h2 id="JDK17"><a href="#JDK17" class="headerlink" title="JDK17"></a>JDK17</h2><p><a href="https://www.oracle.com/java/technologies/downloads/#java17">https://www.oracle.com/java/technologies/downloads/#java17</a></p><p><img src="/post/%E5%A4%9A%E7%89%88%E6%9C%ACJDK%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/tu3.png"></p><h1 id="B-安装"><a href="#B-安装" class="headerlink" title="B.安装"></a>B.安装</h1><p>尽量将jdk文件安装到D盘下的同一个文件夹中，方便整理</p><p>我的路径是：</p><p><img src="/post/%E5%A4%9A%E7%89%88%E6%9C%ACJDK%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/tu4.png"></p><h1 id="C-配置环境变量"><a href="#C-配置环境变量" class="headerlink" title="C.配置环境变量"></a>C.配置环境变量</h1><h2 id="1-设置总的JAVA-HOME"><a href="#1-设置总的JAVA-HOME" class="headerlink" title="1.设置总的JAVA_HOME"></a>1.设置总的JAVA_HOME</h2><p><img src="/post/%E5%A4%9A%E7%89%88%E6%9C%ACJDK%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/tu5.png"></p><p>根据需要更改总的JAVA_HOME的值即可切换jdk版本</p><h2 id="2-path配置"><a href="#2-path配置" class="headerlink" title="2.path配置"></a>2.path配置</h2><p><img src="/post/%E5%A4%9A%E7%89%88%E6%9C%ACJDK%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/tu6.png"></p><p><font color=red>注意：若将以%开头的路径放到第一位，编辑时，无法显示图形化交互编辑界面</font></p><h1 id="D-查看版本切换是否成功"><a href="#D-查看版本切换是否成功" class="headerlink" title="D.查看版本切换是否成功"></a>D.查看版本切换是否成功</h1><p>java -version</p><p><img src="/post/%E5%A4%9A%E7%89%88%E6%9C%ACJDK%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/tu7.png"></p><p><font color=red>注意：切换版本后需要重新启动CMD命令窗口，才会获取到切换后的版本号</font></p><p><img src="/post/%E5%A4%9A%E7%89%88%E6%9C%ACJDK%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/tu8.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;多版本jdk安装 环境配置&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE" scheme="https://umrlll.github.io/categories/JavaSE/"/>
    
    
    <category term="Java" scheme="https://umrlll.github.io/tags/Java/"/>
    
    <category term="环境安装" scheme="https://umrlll.github.io/tags/%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>JDK安装</title>
    <link href="https://umrlll.github.io/post/JDK%E5%AE%89%E8%A3%85/"/>
    <id>https://umrlll.github.io/post/JDK%E5%AE%89%E8%A3%85/</id>
    <published>2022-06-27T10:19:58.000Z</published>
    <updated>2022-06-29T13:12:11.850Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="1-jdk、jre、jvm的区别："><a href="#1-jdk、jre、jvm的区别：" class="headerlink" title="1.jdk、jre、jvm的区别："></a>1.jdk、jre、jvm的区别：</h3><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>jDK：Java Development kit java开发工具包，它提供了几千个类库的源码给我们，我们基于jdk提 供的开发环境去开发我们的代码，目前我们用的jdk1.8就是我们说的java8。</p><p>JRE: java runtime Environment java运行环境，如果你需要将java程序运行你就必须安装加热， 如果你开发好了代码只需要运行那么只安装jre是可以的，但是通常jdk和jre都装</p><p>JVM：java virtual Machine java虚拟机，负责解释运行字节码文件，是跨平台的核心。</p></blockquote><h3 id="2-去官网去下载JDK"><a href="#2-去官网去下载JDK" class="headerlink" title="2.去官网去下载JDK"></a>2.去官网去下载JDK</h3><p><img src="/post/JDK%E5%AE%89%E8%A3%85/tu1.png"></p><p><img src="/post/JDK%E5%AE%89%E8%A3%85/tu2.png"></p><p><img src="/post/JDK%E5%AE%89%E8%A3%85/tu3.png"></p><p><img src="/post/JDK%E5%AE%89%E8%A3%85/tu4.png"></p><p><img src="/post/JDK%E5%AE%89%E8%A3%85/tu5.png"></p><p><img src="/post/JDK%E5%AE%89%E8%A3%85/tu6.png"></p><p>如果没有登录，就登陆或者注册，就可以下载了！！</p><p><img src="/post/JDK%E5%AE%89%E8%A3%85/tu7.png"></p><h3 id="3-安装jdk"><a href="#3-安装jdk" class="headerlink" title="3.安装jdk"></a>3.安装jdk</h3><p>注意：安装jdk的路径不能有中文或空格，以免出现问题！</p><p><img src="/post/JDK%E5%AE%89%E8%A3%85/tu8.png"></p><p><img src="/post/JDK%E5%AE%89%E8%A3%85/tu9.png"></p><p><img src="/post/JDK%E5%AE%89%E8%A3%85/tu10.png"></p><p><img src="/post/JDK%E5%AE%89%E8%A3%85/tu11.png"></p><h3 id="4-配置环境变量"><a href="#4-配置环境变量" class="headerlink" title="4.配置环境变量"></a>4.配置环境变量</h3><p>为什么需要配置环境变量：</p><p> 我们需要通过D:\java8\jdk\bin目录下的javac.exe、java.exe的命令来编译执行java程序，但是我们不会 将源文件放到D:\java8\jdk\bin目录下去，我们一般是将项目放在其他位置，但是要在磁盘的别的位置运 行java.exe命令就找不到，就需需要配置path环境变量告诉windows，如果在该目录找不到java.exe就 去path目录去找java.exe</p><p><img src="/post/JDK%E5%AE%89%E8%A3%85/tu12.png"></p><p><img src="/post/JDK%E5%AE%89%E8%A3%85/tu13.png"></p><p><img src="/post/JDK%E5%AE%89%E8%A3%85/tu14.png"></p><a href="/post/%E5%A4%9A%E7%89%88%E6%9C%ACJDK%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" title="多版本JDK安装环境配置">多版本JDK安装环境配置</a>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h3 id=&quot;1-jdk、jre、jvm的区别：&quot;&gt;&lt;a href=&quot;#1-jdk、jre、jvm的区别：&quot; class=&quot;headerlink&quot; title=&quot;1.jdk、jre、jvm的区别：&quot;&gt;&lt;/a&gt;1.jdk、jre、</summary>
      
    
    
    
    <category term="JavaSE" scheme="https://umrlll.github.io/categories/JavaSE/"/>
    
    
    <category term="Java" scheme="https://umrlll.github.io/tags/Java/"/>
    
    <category term="环境安装" scheme="https://umrlll.github.io/tags/%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>Java基础</title>
    <link href="https://umrlll.github.io/post/Java%E5%9F%BA%E7%A1%80/"/>
    <id>https://umrlll.github.io/post/Java%E5%9F%BA%E7%A1%80/</id>
    <published>2022-06-23T12:43:18.000Z</published>
    <updated>2022-07-02T02:40:02.060Z</updated>
    
    <content type="html"><![CDATA[<p>JavaSE基础</p><span id="more"></span><h1 id="一：Java入门"><a href="#一：Java入门" class="headerlink" title="一：Java入门"></a>一：Java入门</h1><h2 id="A-安装eclipse"><a href="#A-安装eclipse" class="headerlink" title="A.安装eclipse"></a>A.安装eclipse</h2><p>目前市面上常用的集成开发环境(IDE)有：</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>1.eclipse 免费 官网推荐 解压版</p><p>2.myeclipse 插件版，可以生成很多功能，付费，现在用的几乎很少</p><p>3.IntelliJ IDEA 智能提示很强大，付费</p></blockquote><p>目前市面上eclipse2020和intelliJ IDEA 市场占有率各占一半，前期学习用eclipse，后期框架用IntelliJ IDEA</p><p><img src="/post/Java%E5%9F%BA%E7%A1%80/day01/tu1.png"></p><p><img src="/post/Java%E5%9F%BA%E7%A1%80/day01/tu2.png"></p><p><img src="/post/Java%E5%9F%BA%E7%A1%80/day01/tu3.png"></p><p><img src="/post/Java%E5%9F%BA%E7%A1%80/day01/tu4.png"></p><p><img src="/post/Java%E5%9F%BA%E7%A1%80/day01/tu5.png"></p><p><img src="/post/Java%E5%9F%BA%E7%A1%80/day01/tu6.png"></p><p>安装完毕！！！</p><h2 id="B-安装jdk"><a href="#B-安装jdk" class="headerlink" title="B.安装jdk"></a>B.安装jdk</h2><h3 id="1-jdk、jre、jvm的区别："><a href="#1-jdk、jre、jvm的区别：" class="headerlink" title="1.jdk、jre、jvm的区别："></a>1.jdk、jre、jvm的区别：</h3><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>jDK：Java Development kit java开发工具包，它提供了几千个类库的源码给我们，我们基于jdk提 供的开发环境去开发我们的代码，目前我们用的jdk1.8就是我们说的java8。</p><p>JRE: java runtime Environment java运行环境，如果你需要将java程序运行你就必须安装加热， 如果你开发好了代码只需要运行那么只安装jre是可以的，但是通常jdk和jre都装</p><p>JVM：java virtual Machine java虚拟机，负责解释运行字节码文件，是跨平台的核心。</p></blockquote><h3 id="2-去官网去下载JDK"><a href="#2-去官网去下载JDK" class="headerlink" title="2.去官网去下载JDK"></a>2.去官网去下载JDK</h3><p><img src="/day01/tu7.png"></p><p><img src="/day01/tu8.png"></p><p><img src="/day01/tu9.png"></p><p><img src="/day01/tu10.png"></p><p><img src="/day01/tu11.png"></p><p><img src="/day01/tu12.png"></p><p>如果没有登录，就登陆或者注册，就可以下载了！！</p><p><img src="/day01/tu13.png"></p><h3 id="3-安装jdk"><a href="#3-安装jdk" class="headerlink" title="3.安装jdk"></a>3.安装jdk</h3><p>注意：安装jdk的路径不能有中文或空格，以免出现问题！</p><p><img src="/day01/tu14.png"></p><p><img src="/day01/tu15.png"></p><p><img src="/day01/tu16.png"></p><p><img src="/day01/tu17.png"></p><h3 id="4-配置环境变量"><a href="#4-配置环境变量" class="headerlink" title="4.配置环境变量"></a>4.配置环境变量</h3><p>为什么需要配置环境变量：</p><p> 我们需要通过D:\java8\jdk\bin目录下的javac.exe、java.exe的命令来编译执行java程序，但是我们不会 将源文件放到D:\java8\jdk\bin目录下去，我们一般是将项目放在其他位置，但是要在磁盘的别的位置运 行java.exe命令就找不到，就需需要配置path环境变量告诉windows，如果在该目录找不到java.exe就 去path目录去找java.exe</p><p><img src="/day01/tu18.png"></p><p><img src="/day01/tu19.png"></p><p><img src="/day01/tu20.png"></p><h2 id="C-开发项目"><a href="#C-开发项目" class="headerlink" title="C.开发项目"></a>C.开发项目</h2><p><img src="/post/Java%E5%9F%BA%E7%A1%80/day01/tu21.png"></p><p>项目目录：</p><p><img src="/post/Java%E5%9F%BA%E7%A1%80/day01/tu22.png"></p><p><img src="/post/Java%E5%9F%BA%E7%A1%80/day01/tu23.png"></p><h2 id="D-更改字体大小"><a href="#D-更改字体大小" class="headerlink" title="D.更改字体大小"></a>D.更改字体大小</h2><p><img src="/post/Java%E5%9F%BA%E7%A1%80/day01/tu24.png"></p><h2 id="E-开发程序的3个步骤"><a href="#E-开发程序的3个步骤" class="headerlink" title="E.开发程序的3个步骤"></a>E.开发程序的3个步骤</h2><p>1.编写源文件，编写XXX.java源文件 </p><p>2.编译，将XXX.java源文件翻译成XXX.class字节码文件 </p><p>3.运行，在JVMjava虚拟机运行</p><h2 id="F-注释"><a href="#F-注释" class="headerlink" title="F.注释"></a>F.注释</h2><h3 id="1-注释的作用"><a href="#1-注释的作用" class="headerlink" title="1.注释的作用"></a>1.注释的作用</h3><p>通常我们的项目在后期代码量越来越多，为了方便自己或者同事能够看懂你的代码，就需要添加注释对 代码进行说明解释，减少沟通成本。 </p><p>注释后的代码不会被编译运行，因此还可以将作废但是需要保留的代码注释掉保留在文本中。</p><h3 id="2-注释分类"><a href="#2-注释分类" class="headerlink" title="2.注释分类"></a>2.注释分类</h3><p>a.单行注释 </p><p>b.多行注释 </p><p>c.文档注释</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">package day01;&#x2F;** *  * @author 南鸢离梦 * *&#x2F;public class Test1 &#123;public static void main(String[] args) &#123;System.out.println(&quot;Hello world!!&quot;);System.out.println(&quot;我是谁？&quot;);&#125;&#125;</code></pre><h2 id="G-转义字符"><a href="#G-转义字符" class="headerlink" title="G.转义字符"></a>G.转义字符</h2><p>\n用来换行，\t用来空格。</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">System.out.print(&quot;\n高新区是个\n美丽的地方&quot;)</code></pre><h1 id="二：变量"><a href="#二：变量" class="headerlink" title="二：变量"></a>二：变量</h1><h2 id="A-定义"><a href="#A-定义" class="headerlink" title="A.定义"></a>A.定义</h2><p>存储在内存中的值并且能够发生改变，数据需要放在内存中才可以进行计算。变量本质是计算机内存中代表一个”可操作的存储空间“，位置是确定的，但里面的值是不确定的可以改变。通过变量名来访问该对应的存储的内存空间里面的值（变量名存储的是这个数据存在内存的地址）从而操作这个内存存储的值。</p><p>存储在内存里面的数据是瞬时状态的（关机之后就没有了），保存在磁盘的是持久状态的。</p><p>由于计算机内存有限，一般为4G或8G，需要尽可能的节省内存空间，就需要通过变量来存储以达到节省内存空间的目的。</p><p>【字节】</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">字节是内存中最小的存储单位，一个字节byte由8位组成，8个bit，比如6转换成二进制 0000 0110</code></pre><h2 id="B-数据类型"><a href="#B-数据类型" class="headerlink" title="B.数据类型"></a>B.数据类型</h2><p>java是一个强类型语言，每个变量必须声明数据类型，变量的数据类型决定了变量占据的存储空间的大小！通俗讲就是你要根据数据的大小依据数据类型为这个变量开辟合适大小的空间去存储，达到节约空间的目的</p><p>比如:int a&#x3D;10;表示变量a存储空间的大小是4个字节，也就是说int在内存中开辟了4个字节的空间</p><p>​    &#x3D;&#x3D;数据类型分为基本类型和引用类型&#x3D;&#x3D;</p><p><img src="/post/Java%E5%9F%BA%E7%A1%80/day02/tu1.png"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** *  * 变量，存储在内存中的数据，并且可以发生改变 * *&#x2F;public class Test1 &#123;public static void main(String[] args) &#123;&#x2F;&#x2F;需求：需要将10存储在计算机内存中运算&#x2F;&#x2F;1、声明变量：依据数据的大小，根据数据类型开辟合适大小的空间 int 是4个字节存储整数int a;&#x2F;&#x2F;2、赋值：把左边的10通过&#x3D;赋给右边a&#x3D;10;&#x2F;&#x2F;3、使用变量：使用变量里面的值进行计算a&#x3D;a+5;System.out.println(a);&#x2F;&#x2F;声明并赋值进行初始化int b&#x3D;20;int c&#x3D;a+b;System.out.println(&quot;a+b的和：&quot;+c);&#125;&#125;</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test2 &#123;public static void main(String[] args) &#123;&#x2F;&#x2F;存储整数，byte short int longbyte num1 &#x3D; 127;&#x2F;&#x2F;1个字节 -128~127之间short num2 &#x3D; 126;&#x2F;&#x2F;2个字节 int age &#x3D; 27; &#x2F;&#x2F;4个字节，java默认int类型long money &#x3D; 23232323232L;&#x2F;&#x2F; 8个字节存储空间 长整型char sex &#x3D; &#39;s&#39;;&#x2F;&#x2F;字符类型 2个字节&#x2F;&#x2F;浮点类型&#x2F;&#x2F;浮点类型不是一个准确的数！float精确到第七位。double精确度是float的两倍所以叫双精度类型float fenshu1 &#x3D; 98.7F;&#x2F;&#x2F;单精度类型 4个字节double fenshu2 &#x3D; 93.22;&#x2F;&#x2F;双精度类型 8个字节 Java默认是double&#x2F;&#x2F;布尔类型，只能存放true&#x2F;falseboolean hege &#x3D; false;&#x2F;&#x2F;1个bit(1个bit至少也要1byte存储)&#x2F;&#x2F;字符串类型，注意：字符串不是基本类型！它是特殊的引用类型String sexs &#x3D; &quot;male&quot;;String name2 &#x3D; &quot;&quot;; &#x2F;&#x2F;它也是字符串！空字符串&#125;&#125;</code></pre><p>数据类型的存储范围：</p><table><thead><tr><th align="center">数据类型</th><th align="center">关键字</th><th align="center">占用字节</th><th align="center">取值范围</th><th align="center">默认值</th></tr></thead><tbody><tr><td align="center">布尔型</td><td align="center">boolean</td><td align="center">1</td><td align="center">true，false</td><td align="center">false</td></tr><tr><td align="center">字节型</td><td align="center">byte</td><td align="center">1</td><td align="center">-128 ~ 127</td><td align="center">0</td></tr><tr><td align="center">短整型</td><td align="center">short</td><td align="center">2</td><td align="center">-2^15^ ~ 2^15^-1</td><td align="center">0</td></tr><tr><td align="center">整型</td><td align="center">int</td><td align="center">4</td><td align="center">-2^31^ ~ 2^31^-1</td><td align="center">0</td></tr><tr><td align="center">长整型</td><td align="center">long</td><td align="center">8</td><td align="center">-2^63^ ~ 2^63^-1</td><td align="center">0</td></tr><tr><td align="center">字符型</td><td align="center">char</td><td align="center">2</td><td align="center">0 ~ 2^16^-1</td><td align="center">‘\u0000’</td></tr></tbody></table><h2 id="C-变量命名规则"><a href="#C-变量命名规则" class="headerlink" title="C.变量命名规则"></a>C.变量命名规则</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>1.首字母可以以下划线、英文字母、$符号开头，其他部分可以是数字、字母、下划线、$符号；比如_name age age2 $name</p><p>2.如果以两个单词组成的，以驼峰命名法命名，比如myName</p><p>3.变量名最好有意义，不要写abc，方便别人看懂你的代码</p><p>4.不要有关键字，比如int  public等</p></blockquote><h2 id="D-变量种类"><a href="#D-变量种类" class="headerlink" title="D.变量种类"></a>D.变量种类</h2><h3 id="1-局部变量"><a href="#1-局部变量" class="headerlink" title="1.局部变量"></a>1.局部变量</h3><p>在方法或者语句块内部定义的变量，叫做局部变量，生命周期从声明的位置到方法或者语句块执行完毕就会被销毁。</p><p>局部变量必须先声明复制才能使用</p><h3 id="2-全局变量"><a href="#2-全局变量" class="headerlink" title="2.全局变量"></a>2.全局变量</h3><p>也叫成员变量或者叫实例变量，在类里面或者方法外面定义的变量叫全局变量，作用域整个类中，从属于对象，</p><p>生命周期伴随着对象始终，如果不自动初始化，它会自动初始化该变量</p><h3 id="3-静态变量"><a href="#3-静态变量" class="headerlink" title="3.静态变量"></a>3.静态变量</h3><p>也叫类变量，用static修饰，从属于类，在类加载的时候就会被初始化，生命周期从类加载到类卸载</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">static int c ;</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** *  * 全局变量和局部变量的区别 * *&#x2F;public class Test3 &#123;int a&#x3D;10;&#x2F;&#x2F;全局变量，作用于整个类中int b;static name;static int c ;public static void main(String[] args) &#123;int b&#x3D;10; &#x2F;&#x2F;在方法内部或代码块定义的是局部变量。只作用于main方法里面int a&#x3D;15;  &#x2F;&#x2F;局部变量和全局变量可以重名System.out.println(&quot;局部变量b：&quot;+b);&#x2F;&#x2F;当局部变量和全局变量重名的情况下，就近原则，使用局部变量System.out.println(&quot;局部变量a：&quot;+a);Test3 test &#x3D; new Test3();System.out.println(&quot;全局变量a：&quot;+test.a);System.out.println(&quot;静态方法直接调用静态变量：&quot;+c);System.out.println(&quot;静态变量可以通过类名调用&quot;+test.c);&#x2F;&#x2F;由于全局变量是对象调用的引用类型，在堆内存中每月初始值System.out.println(test.name);System.out.println(test.d);&#125;&#x2F;&#x2F;@SuppressWarnings(&quot;unused&quot;)private void show() &#123;&#x2F;&#x2F;System.out.println(&quot;全局变量a：&quot;+a);&#x2F;&#x2F;在这调用不到main方法的局部变量b&#x2F;&#x2F;System.out.println(&quot;局部变量b：&quot;+b);System.out.println(&quot;静态变量可以通过类名调用&quot;+test.c);&#125;&#125;</code></pre><p>​</p><p>​ &#x3D;&#x3D;基本数据类型的数据都是在栈内存中存储，引用类型的数据都是在对内存中存储&#x3D;&#x3D;</p><h2 id="E-数据转换"><a href="#E-数据转换" class="headerlink" title="E.数据转换"></a>E.数据转换</h2><p>&#x3D;&#x3D;一定是数值之间才可以进行转换!&#x3D;&#x3D;</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">int a&#x3D;10;double b&#x3D;9.8;int c&#x3D;(int) b; &#x2F;&#x2F;由于大的空间的值不能放到小的空间，需要强制类型转换，但会丢失精度System.out.println(c);&#x2F;&#x2F;9double d&#x3D;a;&#x2F;&#x2F;把小的空间的值放到更大的空间，能放下，叫自动转换System.out.println(d);&#x2F;&#x2F;10.0&#x2F;&#x2F;扩展：任何数据+&quot;&quot;都变成字符串类型，不能再运算String str&#x3D;123+&quot;&quot;;</code></pre><h2 id="F-控制台输入"><a href="#F-控制台输入" class="headerlink" title="F.控制台输入"></a>F.控制台输入</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Scanner;public class Test5 &#123;public static void main(String[] args) &#123;try (&#x2F;&#x2F;创建input对象Scanner input &#x3D; new Scanner(System.in)) &#123;System.out.print(&quot;请输入姓名：&quot;);String name&#x3D;input.next();&#x2F;&#x2F;next()输入字符串System.out.print(&quot;请输入年龄：&quot;);int age&#x3D;input.nextInt();&#x2F;&#x2F;nextInt()输入整数System.out.println(&quot;我的名字是&quot;+name+&quot;，我的年龄是&quot;+age+&quot;岁！&quot;);&#125;&#125;&#125;</code></pre><h2 id="G-运算符"><a href="#G-运算符" class="headerlink" title="G.运算符"></a>G.运算符</h2><h3 id="a-算术运算符"><a href="#a-算术运算符" class="headerlink" title="a.算术运算符"></a>a.算术运算符</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">+ - * &#x2F; %</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">int a&#x3D;7;int b&#x3D;3;int r1&#x3D;a+b;&#x2F;&#x2F;10int r2&#x3D;a-b;&#x2F;&#x2F;4int r3&#x3D;a*b;&#x2F;&#x2F;21int r4&#x3D;7&#x2F;3;&#x2F;&#x2F;2double r5&#x3D;7&#x2F;3.0;&#x2F;&#x2F;2.3333333333333335System.out.println(r4);System.out.println(r5);&#x2F;&#x2F;取余int r6&#x3D;7%3;&#x2F;&#x2F;1</code></pre><h3 id="b-条件运算符"><a href="#b-条件运算符" class="headerlink" title="b.条件运算符"></a>b.条件运算符</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">  a&gt;b  a&lt;b  a&gt;&#x3D;b  a&lt;&#x3D;b  a&#x3D;&#x3D;b两个值比较  a!&#x3D;b不等于  得到的结果是Boolean类型，结果为true&#x2F;false      int a&#x3D;3;int b&#x3D;7;boolean r1&#x3D;a&#x3D;&#x3D;b;&#x2F;&#x2F;falseboolean r2&#x3D;a!&#x3D;b;&#x2F;&#x2F;trueboolean r3&#x3D;a&gt;b;&#x2F;&#x2F;trueSystem.out.println(r1);System.out.println(r2);      </code></pre><h3 id="c-逻辑运算符"><a href="#c-逻辑运算符" class="headerlink" title="c.逻辑运算符"></a>c.逻辑运算符</h3><p>与或非</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>&amp;&amp;   并且：条件A&amp;&amp;条件B   条件A和条件B都满足为true，才会返回true</p><p>||    或者：条件A||条件B条件A和条件B其中一个满足为true，返回结果为true</p><p>！         非：取反      ！&#x3D;不等于  ！true返回false</p></blockquote><h4 id="面试题：-amp-和-amp-amp-的区别？"><a href="#面试题：-amp-和-amp-amp-的区别？" class="headerlink" title="面试题：&amp;和&amp;&amp;的区别？"></a>面试题：&amp;和&amp;&amp;的区别？</h4><p>​&amp;&amp;具有短路功能，效率更高。</p><h3 id="d-赋值运算符"><a href="#d-赋值运算符" class="headerlink" title="d.赋值运算符"></a>d.赋值运算符</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x3D;   int a&#x3D;10;</code></pre><h4 id="面试题：-x3D-x3D-和-x3D-的区别？"><a href="#面试题：-x3D-x3D-和-x3D-的区别？" class="headerlink" title="面试题：&#x3D;&#x3D;和&#x3D;的区别？"></a>面试题：&#x3D;&#x3D;和&#x3D;的区别？</h4><p>&#x3D;&#x3D;为比较，&#x3D;为赋值</p><h3 id="e-三目运算符（三元运算符）"><a href="#e-三目运算符（三元运算符）" class="headerlink" title="e.三目运算符（三元运算符）"></a>e.三目运算符（三元运算符）</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;*** 算术运算符* 三目运算符*&#x2F;public class Test9 &#123;public static void main(String[] args) &#123;&#x2F;&#x2F;比较条件?满足true赋的值:满足false赋的值int r1&#x3D;8&gt;5?1:0;System.out.println(r1);String r2&#x3D;8&gt;5?&quot;男&quot;:&quot;女&quot;;System.out.println(r2);&#125;&#125;</code></pre><h3 id="f-位运算符"><a href="#f-位运算符" class="headerlink" title="f.位运算符"></a>f.位运算符</h3><p>很少用</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">System.out.println(1&gt;&gt;2);System.out.println(1&lt;&lt;2);</code></pre><h2 id="H-值比较"><a href="#H-值比较" class="headerlink" title="H.值比较"></a>H.值比较</h2><p>1.数值之间比较</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">boolean r1&#x3D;7&#x3D;&#x3D;8; &#x2F;&#x2F;&#x3D;&#x3D;用于数值之间比较</code></pre><p>&#x3D;&#x3D;是用于数值之间比较，比较的是内存地址是否相等。&#x3D;&#x3D;当int 1&#x3D;7;的时候，首先去内存中找是否有7这个常量，如果没有就根据int开辟一个4字节的空间内存7，地址赋给a；当int b&#x3D;7，如果内存有7就没必要重新开辟新的空间，而是将7的地址赋给b变量，因此a&#x3D;&#x3D;b是判断两个值的内存地址是否一致</p><p>&#x3D;&#x3D;基本数据类型是保存在堆（堆栈）内存，数据可共享，引用类型是保存在堆内存，数据不共享&#x3D;&#x3D;</p><p><img src="/post/Java%E5%9F%BA%E7%A1%80/day02/tu2.png"></p><p>2.equals</p><p>字符串比较</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">String name&#x3D;&quot;&quot;;String name1&#x3D;&quot;&quot;;System.out.println(name.equals(name1));&#x2F;&#x2F;比较字符串的值是否相等System.out.println(!name.equals(name1));</code></pre><h2 id="I-常量"><a href="#I-常量" class="headerlink" title="I.常量"></a>I.常量</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;用final修饰的变量叫常量，用于经常使用固定的值而并不会经常发送改变的值，比如一周7天final int WEEKDAY&#x3D;7;System.out.println(&quot;一周&quot;+WEEKDAY+&quot;天&quot;);</code></pre><h2 id="J-Bigdecimal精密计算"><a href="#J-Bigdecimal精密计算" class="headerlink" title="J.Bigdecimal精密计算"></a>J.Bigdecimal精密计算</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;由于double和float不是一个精确的数，不合适去做金融类的计算&#x2F;&#x2F;在java.math包下提供了一个BigInteger和Bigdecimal去做计算double a&#x3D;1.0-0.1-0.1-0.1-0.1-0.1;&#x2F;&#x2F;0.5000000000000001 System.out.println(a);</code></pre><h3 id="a-概述"><a href="#a-概述" class="headerlink" title="a.概述"></a>a.概述</h3><p>Java在java.math包中提供的API类BigDecimal，用来对超过16位有效位的数进行精确的运算。双精度浮点型变量double可以处理16位有效数，但在实际应用中，可能需要对更大或者更小的数进行运算和处理。一般情况下，对于那些不需要准确计算精度的数字，我们可以直接使用Float和Double处理，但是Double.valueOf(String) 和Float.valueOf(String)会丢失精度。所以开发中，如果我们需要精确计算的结果，则必须使用BigDecimal类来操作。</p><p> BigDecimal所创建的是对象，故我们不能使用传统的+、-、*、&#x2F;等算术运算符直接对其对象进行数学运算，而必须调用其相对应的方法。方法中的参数也必须是BigDecimal的对象。构造器是类的特殊方法，专门用来创建对象，特别是带有参数的对象。</p><h3 id="b-常用构造函数"><a href="#b-常用构造函数" class="headerlink" title="b.常用构造函数"></a>b.常用构造函数</h3><h4 id="1-常用构造函数"><a href="#1-常用构造函数" class="headerlink" title="1.常用构造函数"></a>1.常用构造函数</h4><ol><li><p>BigDecimal(int)</p><p>创建一个具有参数所指定整数值的对象</p></li><li><p>BigDecimal(double)</p><p>创建一个具有参数所指定双精度值的对象</p></li><li><p>BigDecimal(long)</p><p>创建一个具有参数所指定长整数值的对象</p></li><li><p>BigDecimal(String)</p><p>创建一个具有参数所指定以字符串表示的数值的对象</p></li></ol><h4 id="2-使用问题分析"><a href="#2-使用问题分析" class="headerlink" title="2.使用问题分析"></a>2.使用问题分析</h4><p>使用示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">BigDecimal a &#x3D;new BigDecimal(0.1);        System.out.println(&quot;a values is:&quot;+a);        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        BigDecimal b &#x3D;new BigDecimal(&quot;0.1&quot;);        System.out.println(&quot;b values is:&quot;+b);</code></pre><p>结果示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">a values is:0.1000000000000000055511151231257827021181583404541015625&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;b values is:0.1</code></pre><p>原因分析：</p><p>1）参数类型为double的构造方法的结果有一定的不可预知性。有人可能认为在Java中写入newBigDecimal(0.1)所创建的BigDecimal正好等于 0.1（非标度值 1，其标度为 1），但是它实际上等于0.1000000000000000055511151231257827021181583404541015625。这是因为0.1无法准确地表示为 double（或者说对于该情况，不能表示为任何有限长度的二进制小数）。这样，传入到构造方法的值不会正好等于 0.1（虽然表面上等于该值）。</p><p>2）String 构造方法是完全可预知的：写入 newBigDecimal(“0.1”) 将创建一个 BigDecimal，它正好等于预期的 0.1。因此，比较而言， 通常建议优先使用String构造方法。</p><p>3）当double必须用作BigDecimal的源时，请注意，此构造方法提供了一个准确转换；它不提供与以下操作相同的结果：先使用Double.toString(double)方法，然后使用BigDecimal(String)构造方法，将double转换为String。要获取该结果，请使用static valueOf(double)方法。</p><h3 id="c-常用方法详解"><a href="#c-常用方法详解" class="headerlink" title="c.常用方法详解"></a>c.常用方法详解</h3><h4 id="1-常用方法"><a href="#1-常用方法" class="headerlink" title="1.常用方法"></a>1.常用方法</h4><ol><li><p>add(BigDecimal)</p><p>BigDecimal对象中的值相加，返回BigDecimal对象</p></li><li><p>subtract(BigDecimal)</p><p>BigDecimal对象中的值相减，返回BigDecimal对象</p></li><li><p>multiply(BigDecimal)</p><p>BigDecimal对象中的值相乘，返回BigDecimal对象</p></li><li><p>divide(BigDecimal)</p><p>BigDecimal对象中的值相除，返回BigDecimal对象</p></li><li><p>toString()</p><p>将BigDecimal对象中的值转换成字符串</p></li><li><p>doubleValue()</p><p>将BigDecimal对象中的值转换成双精度数</p></li><li><p>floatValue()</p><p>将BigDecimal对象中的值转换成单精度数</p></li><li><p>longValue()</p><p>将BigDecimal对象中的值转换成长整数</p></li><li><p>intValue()</p><p>将BigDecimal对象中的值转换成整数</p></li><li><p>BigDecimal remainder(BigDecimal divisor)</p><p>求余数，求BigDecimal类型数据除以divisor的余数。</p></li><li><p>BigDecimal max(BigDecimal value)</p><p>最大数，求两个BigDecimal类型数据的最大值。</p></li><li><p>BigDecimal min(BigDecimal value)</p><p>最小数，求两个BigDecimal类型数据的最小值。</p></li><li><p>BigDecimal abs()</p><p>绝对值，求BigDecimal类型数据的绝对值。</p></li><li><p>BigDecimal negate()</p><p>相反数，求BigDecimal类型数据的相反数。</p></li></ol><h4 id="2-大小比较"><a href="#2-大小比较" class="headerlink" title="2.大小比较"></a>2.大小比较</h4><p>java中对BigDecimal比较大小一般用的是bigdemical的compareTo方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">int a &#x3D; bigdemical.compareTo(bigdemical2)</code></pre><p>返回结果分析：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">a &#x3D; -1,表示bigdemical小于bigdemical2；a &#x3D; 0,表示bigdemical等于bigdemical2；a &#x3D; 1,表示bigdemical大于bigdemical2；</code></pre><p>举例：a大于等于b</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">new bigdemica(a).compareTo(new bigdemical(b)) &gt;&#x3D; 0</code></pre><h3 id="d-BigDecimal格式化"><a href="#d-BigDecimal格式化" class="headerlink" title="d.BigDecimal格式化"></a>d.BigDecimal格式化</h3><p>由于NumberFormat类的format()方法可以使用BigDecimal对象作为其参数，可以利用BigDecimal对超出16位有效数字的货币值，百分值，以及一般数值进行格式化控制。</p><p>以利用BigDecimal对货币和百分比格式化为例。首先，创建BigDecimal对象，进行BigDecimal的算术运算后，分别建立对货币和百分比格式化的引用，最后利用BigDecimal对象作为format()方法的参数，输出其格式化的货币值和百分比。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">NumberFormat currency &#x3D; NumberFormat.getCurrencyInstance(); &#x2F;&#x2F;建立货币格式化引用    NumberFormat percent &#x3D; NumberFormat.getPercentInstance();  &#x2F;&#x2F;建立百分比格式化引用    percent.setMaximumFractionDigits(3); &#x2F;&#x2F;百分比小数点最多3位       BigDecimal loanAmount &#x3D; new BigDecimal(&quot;15000.48&quot;); &#x2F;&#x2F;贷款金额   BigDecimal interestRate &#x3D; new BigDecimal(&quot;0.008&quot;); &#x2F;&#x2F;利率      BigDecimal interest &#x3D; loanAmount.multiply(interestRate); &#x2F;&#x2F;相乘   System.out.println(&quot;贷款金额:\t&quot; + currency.format(loanAmount));    System.out.println(&quot;利率:\t&quot; + percent.format(interestRate));    System.out.println(&quot;利息:\t&quot; + currency.format(interest)); </code></pre><p>结果：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">贷款金额: ￥15,000.48 利率: 0.8% 利息: ￥120.00</code></pre><p>BigDecimal格式化保留2为小数，不足则补0：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class NumberFormat &#123;public static void main(String[] s)&#123;System.out.println(formatToNumber(new BigDecimal(&quot;3.435&quot;)));System.out.println(formatToNumber(new BigDecimal(0)));System.out.println(formatToNumber(new BigDecimal(&quot;0.00&quot;)));System.out.println(formatToNumber(new BigDecimal(&quot;0.001&quot;)));System.out.println(formatToNumber(new BigDecimal(&quot;0.006&quot;)));System.out.println(formatToNumber(new BigDecimal(&quot;0.206&quot;)));    &#125;&#x2F;** * @desc 1.0~1之间的BigDecimal小数，格式化后失去前面的0,则前面直接加上0。 * 2.传入的参数等于0，则直接返回字符串&quot;0.00&quot; * 3.大于1的小数，直接格式化返回字符串 * @param obj传入的小数 * @return *&#x2F;public static String formatToNumber(BigDecimal obj) &#123;DecimalFormat df &#x3D; new DecimalFormat(&quot;#.00&quot;);if(obj.compareTo(BigDecimal.ZERO)&#x3D;&#x3D;0) &#123;return &quot;0.00&quot;;&#125;else if(obj.compareTo(BigDecimal.ZERO)&gt;0&amp;&amp;obj.compareTo(new BigDecimal(1))&lt;0)&#123;return &quot;0&quot;+df.format(obj).toString();&#125;else &#123;return df.format(obj).toString();&#125;&#125;&#125;</code></pre><p>结果为：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">3.440.000.000.000.010.21</code></pre><h3 id="e-BigDecimal常见异常"><a href="#e-BigDecimal常见异常" class="headerlink" title="e.BigDecimal常见异常"></a>e.BigDecimal常见异常</h3><h4 id="除法的时候出现异常"><a href="#除法的时候出现异常" class="headerlink" title="除法的时候出现异常"></a>除法的时候出现异常</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result</code></pre><p><strong>原因分析：</strong></p><p> 通过BigDecimal的divide方法进行除法时当不整除，出现无限循环小数时，就会抛异常：java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result.</p><p><strong>解决方法：</strong></p><p> divide方法设置精确的小数点，如：divide(xxxxx,2)</p><h3 id="f-BigDecimal总结"><a href="#f-BigDecimal总结" class="headerlink" title="f.BigDecimal总结"></a>f.BigDecimal总结</h3><h4 id="1-总结"><a href="#1-总结" class="headerlink" title="1.总结"></a>1.总结</h4><ol><li>在需要精确的小数计算时再使用BigDecimal，BigDecimal的性能比double和float差，在处理庞大，复杂的运算时尤为明显。故一般精度的计算没必要使用BigDecimal。</li><li>尽量使用参数类型为String的构造函数。</li><li>BigDecimal都是不可变的（immutable）的， 在进行每一次四则运算时，都会产生一个新的对象 ，所以在做加减乘除运算时要记得要保存操作后的值。</li></ol><h4 id="2-工具类推荐"><a href="#2-工具类推荐" class="headerlink" title="2.工具类推荐"></a>2.工具类推荐</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.vivo.ars.util;import java.math.BigDecimal;&#x2F;** * 用于高精确处理常用的数学运算 *&#x2F;public class ArithmeticUtils &#123;    &#x2F;&#x2F;默认除法运算精度    private static final int DEF_DIV_SCALE &#x3D; 10;    &#x2F;**     * 提供精确的加法运算     *     * @param v1 被加数     * @param v2 加数     * @return 两个参数的和     *&#x2F;    public static double add(double v1, double v2) &#123;        BigDecimal b1 &#x3D; new BigDecimal(Double.toString(v1));        BigDecimal b2 &#x3D; new BigDecimal(Double.toString(v2));        return b1.add(b2).doubleValue();    &#125;    &#x2F;**     * 提供精确的加法运算     *     * @param v1 被加数     * @param v2 加数     * @return 两个参数的和     *&#x2F;    public static BigDecimal add(String v1, String v2) &#123;        BigDecimal b1 &#x3D; new BigDecimal(v1);        BigDecimal b2 &#x3D; new BigDecimal(v2);        return b1.add(b2);    &#125;    &#x2F;**     * 提供精确的加法运算     *     * @param v1    被加数     * @param v2    加数     * @param scale 保留scale 位小数     * @return 两个参数的和     *&#x2F;    public static String add(String v1, String v2, int scale) &#123;        if (scale &lt; 0) &#123;            throw new IllegalArgumentException(                    &quot;The scale must be a positive integer or zero&quot;);        &#125;        BigDecimal b1 &#x3D; new BigDecimal(v1);        BigDecimal b2 &#x3D; new BigDecimal(v2);        return b1.add(b2).setScale(scale, BigDecimal.ROUND_HALF_UP).toString();    &#125;    &#x2F;**     * 提供精确的减法运算     *     * @param v1 被减数     * @param v2 减数     * @return 两个参数的差     *&#x2F;    public static double sub(double v1, double v2) &#123;        BigDecimal b1 &#x3D; new BigDecimal(Double.toString(v1));        BigDecimal b2 &#x3D; new BigDecimal(Double.toString(v2));        return b1.subtract(b2).doubleValue();    &#125;    &#x2F;**     * 提供精确的减法运算。     *     * @param v1 被减数     * @param v2 减数     * @return 两个参数的差     *&#x2F;    public static BigDecimal sub(String v1, String v2) &#123;        BigDecimal b1 &#x3D; new BigDecimal(v1);        BigDecimal b2 &#x3D; new BigDecimal(v2);        return b1.subtract(b2);    &#125;    &#x2F;**     * 提供精确的减法运算     *     * @param v1    被减数     * @param v2    减数     * @param scale 保留scale 位小数     * @return 两个参数的差     *&#x2F;    public static String sub(String v1, String v2, int scale) &#123;        if (scale &lt; 0) &#123;            throw new IllegalArgumentException(                    &quot;The scale must be a positive integer or zero&quot;);        &#125;        BigDecimal b1 &#x3D; new BigDecimal(v1);        BigDecimal b2 &#x3D; new BigDecimal(v2);        return b1.subtract(b2).setScale(scale, BigDecimal.ROUND_HALF_UP).toString();    &#125;    &#x2F;**     * 提供精确的乘法运算     *     * @param v1 被乘数     * @param v2 乘数     * @return 两个参数的积     *&#x2F;    public static double mul(double v1, double v2) &#123;        BigDecimal b1 &#x3D; new BigDecimal(Double.toString(v1));        BigDecimal b2 &#x3D; new BigDecimal(Double.toString(v2));        return b1.multiply(b2).doubleValue();    &#125;    &#x2F;**     * 提供精确的乘法运算     *     * @param v1 被乘数     * @param v2 乘数     * @return 两个参数的积     *&#x2F;    public static BigDecimal mul(String v1, String v2) &#123;        BigDecimal b1 &#x3D; new BigDecimal(v1);        BigDecimal b2 &#x3D; new BigDecimal(v2);        return b1.multiply(b2);    &#125;    &#x2F;**     * 提供精确的乘法运算     *     * @param v1    被乘数     * @param v2    乘数     * @param scale 保留scale 位小数     * @return 两个参数的积     *&#x2F;    public static double mul(double v1, double v2, int scale) &#123;        BigDecimal b1 &#x3D; new BigDecimal(Double.toString(v1));        BigDecimal b2 &#x3D; new BigDecimal(Double.toString(v2));        return round(b1.multiply(b2).doubleValue(), scale);    &#125;    &#x2F;**     * 提供精确的乘法运算     *     * @param v1    被乘数     * @param v2    乘数     * @param scale 保留scale 位小数     * @return 两个参数的积     *&#x2F;    public static String mul(String v1, String v2, int scale) &#123;        if (scale &lt; 0) &#123;            throw new IllegalArgumentException(                    &quot;The scale must be a positive integer or zero&quot;);        &#125;        BigDecimal b1 &#x3D; new BigDecimal(v1);        BigDecimal b2 &#x3D; new BigDecimal(v2);        return b1.multiply(b2).setScale(scale, BigDecimal.ROUND_HALF_UP).toString();    &#125;    &#x2F;**     * 提供（相对）精确的除法运算，当发生除不尽的情况时，精确到     * 小数点以后10位，以后的数字四舍五入     *     * @param v1 被除数     * @param v2 除数     * @return 两个参数的商     *&#x2F;    public static double div(double v1, double v2) &#123;        return div(v1, v2, DEF_DIV_SCALE);    &#125;    &#x2F;**     * 提供（相对）精确的除法运算。当发生除不尽的情况时，由scale参数指     * 定精度，以后的数字四舍五入     *     * @param v1    被除数     * @param v2    除数     * @param scale 表示表示需要精确到小数点以后几位。     * @return 两个参数的商     *&#x2F;    public static double div(double v1, double v2, int scale) &#123;        if (scale &lt; 0) &#123;            throw new IllegalArgumentException(&quot;The scale must be a positive integer or zero&quot;);        &#125;        BigDecimal b1 &#x3D; new BigDecimal(Double.toString(v1));        BigDecimal b2 &#x3D; new BigDecimal(Double.toString(v2));        return b1.divide(b2, scale, BigDecimal.ROUND_HALF_UP).doubleValue();    &#125;    &#x2F;**     * 提供（相对）精确的除法运算。当发生除不尽的情况时，由scale参数指     * 定精度，以后的数字四舍五入     *     * @param v1    被除数     * @param v2    除数     * @param scale 表示需要精确到小数点以后几位     * @return 两个参数的商     *&#x2F;    public static String div(String v1, String v2, int scale) &#123;        if (scale &lt; 0) &#123;            throw new IllegalArgumentException(&quot;The scale must be a positive integer or zero&quot;);        &#125;        BigDecimal b1 &#x3D; new BigDecimal(v1);        BigDecimal b2 &#x3D; new BigDecimal(v1);        return b1.divide(b2, scale, BigDecimal.ROUND_HALF_UP).toString();    &#125;    &#x2F;**     * 提供精确的小数位四舍五入处理     *     * @param v     需要四舍五入的数字     * @param scale 小数点后保留几位     * @return 四舍五入后的结果     *&#x2F;    public static double round(double v, int scale) &#123;        if (scale &lt; 0) &#123;            throw new IllegalArgumentException(&quot;The scale must be a positive integer or zero&quot;);        &#125;        BigDecimal b &#x3D; new BigDecimal(Double.toString(v));        return b.setScale(scale, BigDecimal.ROUND_HALF_UP).doubleValue();    &#125;    &#x2F;**     * 提供精确的小数位四舍五入处理     *     * @param v     需要四舍五入的数字     * @param scale 小数点后保留几位     * @return 四舍五入后的结果     *&#x2F;    public static String round(String v, int scale) &#123;        if (scale &lt; 0) &#123;            throw new IllegalArgumentException(                    &quot;The scale must be a positive integer or zero&quot;);        &#125;        BigDecimal b &#x3D; new BigDecimal(v);        return b.setScale(scale, BigDecimal.ROUND_HALF_UP).toString();    &#125;    &#x2F;**     * 取余数     *     * @param v1    被除数     * @param v2    除数     * @param scale 小数点后保留几位     * @return 余数     *&#x2F;    public static String remainder(String v1, String v2, int scale) &#123;        if (scale &lt; 0) &#123;            throw new IllegalArgumentException(                    &quot;The scale must be a positive integer or zero&quot;);        &#125;        BigDecimal b1 &#x3D; new BigDecimal(v1);        BigDecimal b2 &#x3D; new BigDecimal(v2);        return b1.remainder(b2).setScale(scale, BigDecimal.ROUND_HALF_UP).toString();    &#125;    &#x2F;**     * 取余数  BigDecimal     *     * @param v1    被除数     * @param v2    除数     * @param scale 小数点后保留几位     * @return 余数     *&#x2F;    public static BigDecimal remainder(BigDecimal v1, BigDecimal v2, int scale) &#123;        if (scale &lt; 0) &#123;            throw new IllegalArgumentException(                    &quot;The scale must be a positive integer or zero&quot;);        &#125;        return v1.remainder(v2).setScale(scale, BigDecimal.ROUND_HALF_UP);    &#125;    &#x2F;**     * 比较大小     *     * @param v1 被比较数     * @param v2 比较数     * @return 如果v1 大于v2 则 返回true 否则false     *&#x2F;    public static boolean compare(String v1, String v2) &#123;        BigDecimal b1 &#x3D; new BigDecimal(v1);        BigDecimal b2 &#x3D; new BigDecimal(v2);        int bj &#x3D; b1.compareTo(b2);        boolean res;        if (bj &gt; 0)            res &#x3D; true;        else            res &#x3D; false;        return res;    &#125;&#125;</code></pre><h2 id="K-上机作业"><a href="#K-上机作业" class="headerlink" title="K.上机作业"></a>K.上机作业</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">控制台输入语文、数学、英语三门课程的成绩，得到总分和平均分</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test11 &#123;public static void main(String[] args) &#123;Scanner input&#x3D;new Scanner(System.in);        System.out.println(&quot;请输入语文成绩:&quot;);int yuwen&#x3D;input.nextInt();System.out.println(&quot;请输入数学成绩:&quot;);int shuxue&#x3D;input.nextInt();System.out.println(&quot;请输入英语成绩:&quot;);int yingyu&#x3D;input.nextInt();        &#x2F;&#x2F;统计总分int total&#x3D;yuwen+shuxue+yingyu;        System.out.println(&quot;3门课程的总分是:&quot;+total);&#x2F;&#x2F;平均分double avgScore&#x3D;total&#x2F;3.0;System.out.println(&quot;3门课程的平均分是:&quot;+avgScore);&#125;&#125;</code></pre><p>作业：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test12 &#123;public static void main(String[] args) &#123;Scanner input&#x3D;new Scanner(System.in);System.out.println(&quot;请输入一个4位长度的整数:&quot;);int num&#x3D;input.nextInt();&#x2F;&#x2F;分别统计出各位、十位、百位、千位的数&#x2F;&#x2F; 1234&#125;&#125;</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Scanner;public class Test7 &#123;public static void main(String[] args) &#123;Scanner input&#x3D;new Scanner(System.in);System.out.println(&quot;请输入一个4位长度的整数：&quot;);int num&#x3D; input.nextInt();int geWei &#x3D;num%10;int shiWei&#x3D;num&#x2F;10%10;int baiWei&#x3D;num&#x2F;100%10;int qianWei&#x3D;num&#x2F;1000;int num1&#x3D;qianWei+baiWei*10+shiWei*100+geWei*1000;System.out.println(&quot;个位&quot;+geWei+&quot;十位&quot;+shiWei+&quot;百位&quot;+baiWei+&quot;千位&quot;+qianWei);System.out.println(num1);        int total&#x3D;geWei+shiWei+baiWei+qianWei;String message&#x3D;total&gt;20?&quot;幸运顾客&quot;:&quot;谢谢惠顾&quot;;System.out.println(message);        input.close();&#125;&#125;</code></pre><h1 id="三：选择结构"><a href="#三：选择结构" class="headerlink" title="三：选择结构"></a>三：选择结构</h1><p>用于选择和判断</p><h2 id="A-if结构"><a href="#A-if结构" class="headerlink" title="A.if结构"></a>A.if结构</h2><h3 id="a-简单if"><a href="#a-简单if" class="headerlink" title="a.简单if"></a>a.简单if</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">int money&#x3D;10;if(money&gt;100)&#123;System.out.println(&quot;买兰博基尼&quot;);&#125;</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">int money&#x3D;10;if(money&gt;100)&#123;System.out.println(&quot;买兰博基尼&quot;);&#125;else &#123;System.out.println(&quot;没有钱，坐公交车&quot;);&#125;</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">Scanner input&#x3D;new Scanner(System.in);double zhekou;&#x2F;&#x2F;折扣System.out.print(&quot;请输入您的性别:&quot;);String sex&#x3D;input.next();if(&quot;男&quot;.equals(sex))&#123;&#x2F;&#x2F;根据性别来判断折扣zhekou&#x3D;0.8;&#125;else &#123;zhekou&#x3D;0.5;&#125;System.out.println(&quot;您的折扣是:&quot;+zhekou+&quot;折!&quot;);&#125;</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">Scanner input&#x3D;new Scanner(System.in);double zhekou;&#x2F;&#x2F;折扣System.out.print(&quot;请输入您的性别:&quot;);char sex&#x3D;input.next().charAt(0);&#x2F;&#x2F;charAt是根据索引取到字符串第几个字符if(sex&#x3D;&#x3D;&#39;男&#39;)&#123;&#x2F;&#x2F;根据性别来判断折扣zhekou&#x3D;0.8;&#125;else &#123;zhekou&#x3D;0.5;&#125;System.out.println(&quot;您的折扣是:&quot;+zhekou+&quot;折!&quot;);</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;*** 简单if结构* 输入语文和数学的成绩* 如果语文大于95并且数学大于90分，奖励劳斯莱斯一辆* 或者语文100分并且数学大于80分，也奖励劳斯莱斯一辆**&#x2F;public class Test5 &#123;public static void main(String[] args) &#123;Scanner input&#x3D;new Scanner(System.in);System.out.print(&quot;请输入语文成绩:&quot;);int yuwen&#x3D;input.nextInt();System.out.print(&quot;请输入数学成绩:&quot;);int shuxue&#x3D;input.nextInt();        if((yuwen&gt;&#x3D;95&amp;&amp;shuxue&gt;&#x3D;90)||(yuwen&#x3D;&#x3D;100&amp;&amp;shuxue&gt;&#x3D;80))&#123;System.out.println(&quot;奖励劳斯莱斯一辆！&quot;);&#125;else &#123;System.out.println(&quot;抱歉，不奖励！&quot;);&#125;&#125;&#125;</code></pre><h3 id="b-多重if"><a href="#b-多重if" class="headerlink" title="b.多重if"></a>b.多重if</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;*** 多重if结构，有多种选择但是选择一种* 输入语文成绩* 如果大于90分，奖励兰博基尼一台* 如果大于80分，奖励奔驰S一台* 如果大于60分，奖励宝马5系一台* 如果不及格，不奖励**&#x2F;public class Test6 &#123;public static void main(String[] args) &#123;Scanner input&#x3D;new Scanner(System.in);System.out.print(&quot;请输入语文成绩:&quot;);int yuwen&#x3D;input.nextInt();        if(yuwen&gt;&#x3D;90) &#123;System.out.println(&quot;奖励兰博基尼一台！&quot;);&#125; else if(yuwen&gt;&#x3D;80) &#123;System.out.println(&quot;奖励奔驰S一台一台！&quot;);&#125;else if(yuwen&gt;&#x3D;60) &#123;System.out.println(&quot;奖励宝马5系一台！&quot;);&#125;else &#123;System.out.println(&quot;不及格，不奖励&quot;);&#125;&#125;&#125;</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;*** 多重if结构，用于多种选择* 多重if结构可用于区间判断，也可以用于等值判断*&#x2F;public class Test7 &#123;public static void main(String[] args) &#123;Scanner input&#x3D;new Scanner(System.in);String foodName;&#x2F;&#x2F;食物System.out.print(&quot;请输入星期:&quot;);int week&#x3D;input.nextInt();        if(week&#x3D;&#x3D;1)&#123;foodName&#x3D;&quot;肯德基&quot;;&#125;else if (week&#x3D;&#x3D;2||week&#x3D;&#x3D;3) &#123;foodName&#x3D;&quot;必胜客&quot;;&#125;else if (week&#x3D;&#x3D;4) &#123;foodName&#x3D;&quot;德克士&quot;;&#125;else if (week&#x3D;&#x3D;5) &#123;foodName&#x3D;&quot;华莱士&quot;;&#125;else &#123;foodName&#x3D;&quot;泡面&quot;;&#125;System.out.println(&quot;吃:&quot;+foodName);&#125;&#125;</code></pre><h3 id="c-嵌套if"><a href="#c-嵌套if" class="headerlink" title="c.嵌套if"></a>c.嵌套if</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**** 嵌套if结构**&#x2F;public class Test8 &#123;public static void main(String[] args) &#123;Scanner input &#x3D; new Scanner(System.in);String foodName &#x3D; &quot;&quot;;&#x2F;&#x2F; 食物System.out.print(&quot;请输入星期:&quot;);int week &#x3D; input.nextInt();        if (week &gt;&#x3D; 1 &amp;&amp; week &lt;&#x3D; 7) &#123;if (week &#x3D;&#x3D; 1) &#123;foodName &#x3D; &quot;肯德基&quot;;&#125; else if (week &#x3D;&#x3D; 2 || week &#x3D;&#x3D; 3) &#123;foodName &#x3D; &quot;必胜客&quot;;&#125; else if (week &#x3D;&#x3D; 4) &#123;foodName &#x3D; &quot;德克士&quot;;&#125; else if (week &#x3D;&#x3D; 5) &#123;foodName &#x3D; &quot;华莱士&quot;;&#125; else &#123;foodName &#x3D; &quot;泡面&quot;;&#125;System.out.println(&quot;吃:&quot; + foodName);&#125; else &#123;System.out.println(&quot;抱歉，只能输入1-7之间的整数！&quot;);&#125;&#125;&#125;</code></pre><h2 id="B-switch结构"><a href="#B-switch结构" class="headerlink" title="B.switch结构"></a>B.switch结构</h2><p>&#x3D;&#x3D;switch也能用于多重选择，但是switch只能用于等值判断，不能用于区间判断&#x3D;&#x3D;</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args) &#123;Scanner input&#x3D;new Scanner(System.in);System.out.println(&quot;输入星期：&quot;);int days&#x3D;input.nextInt();String food &#x3D; null;switch (days) &#123;case 1:food&#x3D;&quot;KFC&quot;;break;case 2:case 3:food&#x3D;&quot;BSK&quot;;break;case 4:food&#x3D;&quot;DKS&quot;;break;case 5:food&#x3D;&quot;饺子&quot;;break;case 6:case 7:food&#x3D;&quot;泡面&quot;;break;default:break;&#125;System.out.println(&quot;吃：&quot;+food);input.close();&#125;</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args) &#123;Scanner input&#x3D;new Scanner(System.in);System.out.println(&quot;输入星期：&quot;);int days&#x3D;input.nextInt();String food &#x3D; null;if(days&gt;7||days&lt;1) &#123;System.out.println(&quot;error&quot;);&#125;else &#123;switch (days) &#123;case 1:food&#x3D;&quot;KFC&quot;;break;case 2:case 3:food&#x3D;&quot;BSK&quot;;break;case 4:food&#x3D;&quot;DKS&quot;;break;case 5:food&#x3D;&quot;饺子&quot;;break;case 6:case 7:food&#x3D;&quot;泡面&quot;;break;default:break;&#125;System.out.println(&quot;吃：&quot;+food);&#125;input.close();&#125;</code></pre><h2 id="C-上机作业"><a href="#C-上机作业" class="headerlink" title="C.上机作业"></a>C.上机作业</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">*************中兴爱买不买购物超市系统***********1.帽子 2.T恤 3.裤衩10￥ 15￥ 30￥请输入编号选择商品:2请选择购买的数量:5您购买的商品:T恤,金额是:75请输入支付的金额:100找零:25</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Scanner;public class Test8 &#123;public static void main(String[] args) &#123;Scanner input &#x3D;new Scanner(System.in);System.out.println(&quot;********超市********&quot;);System.out.println(&quot;1.帽子\t2.T恤\t3.羽绒服&quot;);System.out.println(&quot;10￥\t15￥\t40￥&quot;);System.out.println(&quot;请输入要购买的的商品编码：&quot;);int bianMa&#x3D;input.nextInt();String shangPin&#x3D;null;int price&#x3D;0;if(bianMa&gt;&#x3D;1&amp;&amp;bianMa&lt;&#x3D;3) &#123;if (bianMa&#x3D;&#x3D;1) &#123;shangPin&#x3D;&quot;帽子&quot;;price&#x3D;10;&#125; else if (bianMa&#x3D;&#x3D;2) &#123;shangPin&#x3D;&quot;T恤&quot;;price&#x3D;15;&#125; else &#123;shangPin&#x3D;&quot;羽绒服&quot;;price&#x3D;40;&#125;System.out.println(&quot;您选中的的商品为：&quot;+shangPin+&quot;此商品的单价为：&quot;+price);System.out.println(&quot;请输入你要购买的数量：&quot;);int count&#x3D;input.nextInt();int total&#x3D;0;total&#x3D;count*price;System.out.println(&quot;您需要支付的金额：&quot;+total);System.out.println(&quot;您支付的金额：&quot;);int money&#x3D;input.nextInt();int retuenMoney&#x3D;money-total;if (retuenMoney&gt;0) &#123;System.out.println(retuenMoney);&#125;else &#123;System.out.println(&quot;金额不足&quot;);&#125;if(total&gt;1000) &#123;int lucknum&#x3D;(int) (Math.random()*10)+1;System.out.println(lucknum);if (lucknum&gt;5&amp;&amp;lucknum&lt;&#x3D;8) &#123;System.out.println(&quot;恭喜获得三等奖：垃圾桶10个&quot;);&#125; else if(lucknum&gt;8&amp;&amp;lucknum&lt;&#x3D;9)&#123;System.out.println(&quot;恭喜获得二等奖：冰箱一台&quot;);&#125;else if(lucknum&#x3D;&#x3D;10)&#123;System.out.println(&quot;恭喜获得一等奖：洗衣机一台&quot;);&#125;else &#123;System.out.println(&quot;恭喜获得安慰奖：抽纸10包&quot;);&#125;&#125;else &#123;System.out.println(&quot;无法参与抽奖&quot;);&#125;&#125;else &#123;System.out.println(&quot;请输入正确的商品编码：&quot;);&#125;input.close();&#125;&#125;</code></pre><h2 id="D-代码调试"><a href="#D-代码调试" class="headerlink" title="D.代码调试"></a>D.代码调试</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">我们可以通过调试模式让原本自动执行的代码按原本的执行轨迹不变，变成手动一行一行的去执行，就可以看到代码执行，也能看到程序的漏洞。    1.可以看到代码一步步的执行    2.</code></pre><h1 id="四：循环结构"><a href="#四：循环结构" class="headerlink" title="四：循环结构"></a>四：循环结构</h1><h2 id="A-定义-1"><a href="#A-定义-1" class="headerlink" title="A.定义"></a>A.定义</h2><p>循环：在特定的条件下重复做一件事</p><h2 id="B-循环分类"><a href="#B-循环分类" class="headerlink" title="B.循环分类"></a>B.循环分类</h2><h3 id="1-while循环"><a href="#1-while循环" class="headerlink" title="1.while循环"></a>1.while循环</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">先判断，后执行；先判断条件是否满足，如果满足为true，就继续执行</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">while(布尔表达式)&#123;    &#x2F;&#x2F;循环内容&#125;</code></pre><p>只要布尔表达式为true，循环体会一直执行下去。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test &#123;    public static void main(String args[]) &#123;    int x &#x3D; 10;        while( x &lt; 20 ) &#123;                    System.out.print(&quot;value of x : &quot; + x );                     x++;          System.out.print(&quot;\n&quot;);               &#125;        &#125; &#125; </code></pre><h3 id="2-do-while循环"><a href="#2-do-while循环" class="headerlink" title="2.do-while循环"></a>2.do-while循环</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">对于while语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。do…while循环和while循环相似，不同的是，do…while循环至少会执行一次。</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">do &#123;       &#x2F;&#x2F;代码语句&#125;while(布尔表达式);</code></pre><p><strong>注意：</strong>布尔表达式在循环体的后面，所以语句块在检测布尔表达式之前已经执行了。 如果布尔表达式的值为true，则语句块一直执行，直到布尔表达式的值为false。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test &#123;   public static void main(String args[])&#123;      int x &#x3D; 10;      do&#123;         System.out.print(&quot;value of x : &quot; + x );         x++;         System.out.print(&quot;\n&quot;);      &#125;while( x &lt; 20 );    &#125; &#125; </code></pre><h3 id="3-for循环"><a href="#3-for循环" class="headerlink" title="3.for循环"></a>3.for循环</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">虽然所有循环结构都可以用while或者do...while表示，但Java提供了另一种语句 —— for循环，使一些循环结构变得更加简单。for循环执行的次数是在执行前就确定的。语法格式如下：</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">for(初始化; 布尔表达式; 更新) &#123;    &#x2F;&#x2F;代码语句&#125;</code></pre><p>关于for循环有以下几点说明：</p><ul><li>最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。</li><li>然后，检测布尔表达式的值。如果为true，循环体被执行。如果为false，循环终止，开始执行循环体后面的语句。</li><li>执行一次循环后，更新循环控制变量。</li><li>再次检测布尔表达式。循环执行上面的过程。</li></ul><h3 id="4-加强for循环"><a href="#4-加强for循环" class="headerlink" title="4.加强for循环"></a>4.加强for循环</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">Java5引入了一种主要用于数组的增强型for循环。Java增强for循环语法格式如下:</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">for(声明语句 : 表达式)&#123;   &#x2F;&#x2F;代码句子&#125;</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。表达式：表达式是要访问的数组名，或者是返回值为数组的方法。</code></pre><h2 id="C-关键字"><a href="#C-关键字" class="headerlink" title="C.关键字"></a>C.关键字</h2><h3 id="1-break关键字"><a href="#1-break关键字" class="headerlink" title="1.break关键字"></a>1.break关键字</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">reak主要用在循环语句或者switch语句中，用来跳出整个语句块。break跳出最里层的循环，并且继续执行该循环下面的语句。</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test &#123;   public static void main(String args[]) &#123;      int [] numbers &#x3D; &#123;10, 20, 30, 40, 50&#125;;      for(int x : numbers ) &#123;         if( x &#x3D;&#x3D; 30 ) &#123;      break;         &#125;         System.out.print( x );         System.out.print(&quot;\n&quot;);      &#125;   &#125;&#125;</code></pre><h3 id="2-continue关键字"><a href="#2-continue关键字" class="headerlink" title="2.continue关键字"></a>2.continue关键字</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">continue适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。在for循环中，continue语句使程序立即跳转到更新语句。在while或者do…while循环中，程序立即跳转到布尔表达式的判断语句。</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test &#123;   public static void main(String args[]) &#123;      int [] numbers &#x3D; &#123;10, 20, 30, 40, 50&#125;;      for(int x : numbers ) &#123;         if( x &#x3D;&#x3D; 30 ) &#123;      continue;         &#125;         System.out.print( x );         System.out.print(&quot;\n&quot;);      &#125;   &#125;&#125;</code></pre><h3 id="3-return"><a href="#3-return" class="headerlink" title="3.return"></a>3.return</h3><p>return作为方法的返回值</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public String getName() &#123; return name; &#125;</code></pre><h2 id="D-i-和-i的区别"><a href="#D-i-和-i的区别" class="headerlink" title="D.i++和++i的区别"></a>D.i++和++i的区别</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">int a&#x3D;5; int b&#x3D;a+++1;&#x2F;&#x2F;先运算再自增，b结果是6 int c&#x3D;++a+1;&#x2F;&#x2F;先自增再运算,c结果是7 System.out.println(&quot;b:&quot;+b+&quot;,c:&quot;+c);</code></pre><h1 id="五：数组"><a href="#五：数组" class="headerlink" title="五：数组"></a>五：数组</h1><h2 id="A-声明数组"><a href="#A-声明数组" class="headerlink" title="A.声明数组"></a>A.声明数组</h2><p>首先必须声明数组变量，才能在程序中使用数组。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">dataType[] arrayRefVar;   &#x2F;&#x2F; 首选的方法或dataType arrayRefVar[];  &#x2F;&#x2F; 效果相同，但不是首选方法</code></pre><h2 id="B-创建数组"><a href="#B-创建数组" class="headerlink" title="B.创建数组"></a>B.创建数组</h2><p>Java 语言使用 new操作符来创建数组</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">arrayRefVar &#x3D; new dataType[arraySize];</code></pre><p>上面的语法语句做了两件事：</p><ul><li>一、使用 dataType[arraySize] 创建了一个数组。</li><li>二、把新创建的数组的引用赋值给变量 arrayRefVar。</li></ul><p>数组变量的声明，和创建数组可以用一条语句完成，如下所示：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">dataType[] arrayRefVar &#x3D; new dataType[arraySize];</code></pre><p>另外，还可以使用如下的方式创建数组。</p><pre class="line-numbers language-jav" data-language="jav"><code class="language-jav">dataType[] arrayRefVar &#x3D; &#123;value0, value1, ..., valuek&#125;;</code></pre><p>数组的元素是通过索引访问的。数组索引从0开始，所以索引值从 0 到 arrayRefVar.length-1。</p><p>那么当数组开辟空间之后，就可以采用如下的方式的操作：</p><ul><li>数组的访问通过索引完成，即：“数组名称[索引]”，但是需要注意的是，数组的索引从0开始，所以索引的范围就是0 ~ 数组长度-1，例如开辟了3个空间的数组，所以可以使用的索引是：0,1,2，如果此时访问的时候超过了数组的索引范围，会产生 java.lang.ArrayIndexOutOfBoundsException 异常信息；</li><li>当我们数组采用动态初始化开辟空间后，数组里面的每一个元素都是该数组对应数据类型的默认值；</li><li>数组本身是一个有序的集合操作，所以对于数组的内容操作往往会采用循环的模式完成，数组是一个有限的数据集合，所以应该使用 for 循环。</li><li>在 Java 中提供有一种动态取得数组长度的方式：数组名称.length；</li></ul><pre class="line-numbers language-jav" data-language="jav"><code class="language-jav">数组属于引用数据类型，所以在数组使用之前一定要开辟空间（实例化），如果使用了没有开辟空间的数组，则一定会出现 NullPointerException 异常信息：</code></pre><p><img src="/day01/tu01.png"></p><h2 id="C-Arrays类"><a href="#C-Arrays类" class="headerlink" title="C.Arrays类"></a>C.Arrays类</h2><p>java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。具有以下功能：</p><ul><li>给数组赋值：通过 fill 方法。</li><li>对数组排序：通过 sort 方法,按升序。</li><li>比较数组：通过 equals 方法比较数组中元素值是否相等。</li><li>查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。</li></ul><table><thead><tr><th align="center">序号</th><th align="center">方法和说明</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><strong>public static int binarySearch(Object[] a, Object key)</strong><br/>用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(<em>插入点</em>) - 1)。</td></tr><tr><td align="center">2</td><td align="center"><strong>public static boolean equals(long[] a, long[] a2)</strong><br/>如果两个指定的 long 型数组彼此<em>相等</em>，则返回 true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</td></tr><tr><td align="center">3</td><td align="center"><strong>public static void fill(int[] a, int val)</strong><br/>将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</td></tr><tr><td align="center">4</td><td align="center"><strong>public static void sort(Object[] a)</strong> 对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</td></tr></tbody></table><h1 id="六：面向对象"><a href="#六：面向对象" class="headerlink" title="六：面向对象"></a>六：面向对象</h1><h2 id="A-基本概念"><a href="#A-基本概念" class="headerlink" title="A.基本概念"></a>A.基本概念</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>面向对象思想将客观世界中的事物描述为对象，并通过抽象思维方法将需要解决的实际问题分解成人们易于理解的对象模型，然后通过这些对象模型来构建应用程序的功能</p><p>面向对象的一些概念</p><p>类、对象、继承、封装、多态等</p></blockquote><p>&#x3D;&#x3D;Object Oriented Programming 面向对象编程，是java编程思想中最重要的编程思想！&#x3D;&#x3D;</p><p>在OOP之前我们是面向过程的：</p><p>面向过程编程：把一个项目在一个类中从上到下去编写代码，把一个事件分成每一步去执行，比如C语言</p><p>面向过程的弊端：</p><pre class="line-numbers language-jav" data-language="jav"><code class="language-jav">1.代码都在一个类文件中，自上而下执行，代码的耦合度非常高，后期的扩展功能和维护的成本很高 2.代码自上而下执行，代码的复用性不高，不能提高开发效率</code></pre><h2 id="B-对象的概念"><a href="#B-对象的概念" class="headerlink" title="B.对象的概念"></a>B.对象的概念</h2><p>​        所谓对象就是真实世界中的实体，对象与实体是一一对应的，也就是说现实世界中每一个实体都是一个对象，它是一种具体的概念。</p><p>对象有以下特点：</p><ul><li>对象具有属性和行为。</li><li>对象具有变化的状态。</li><li>对象具有唯一性。</li><li>对象都是某个类别的实例。</li><li>一切皆为对象，真实世界中的所有事物都可以视为对象。</li></ul><h3 id="a-类和对象"><a href="#a-类和对象" class="headerlink" title="a.类和对象"></a>a.类和对象</h3><p>​在面向对象中，类和对象是最基本、最重要的组成单元。类实际上是表示一个客观世界某类群体的一些基本特征抽象。对象就是表示一个个具体的东西。所以说类是对象的抽象，对象是类的具体。</p><p>&#x3D;&#x3D;类是概念模型，定义对象的所有特性和所需的操作，对象是真实的模型，是一个具体的实体。&#x3D;&#x3D;</p><p>类是描述了一组有相同特性（属性）和相同行为（方法）的一组对象的集合。</p><p>对象或实体所拥有的特征在类中表示时称为类的属性。例如，每个人都具有姓名、年龄和体重，这是所有人共有的特征。但是每一个对象的属性值又各不相同，例如，小明和小红都具有体重这个属性，但是他们的体重值是不同的。</p><p>对象执行的操作称为类的方法。比如，“人”这个对象都具有的行为是“吃饭”，因此，吃饭就是“人”类的一个方法。</p><p>类是实体对象的概念模型，因此通常是笼统的、不具体的。</p><p>类是构造面向对象程序的基本单位，是抽取了同类对象的共同属性和方法所形成的对象或实体的“模板”。而对象是现实世界中实体的描述，对象要创建才存在，有了对象才能对对象进行操作。类是对象的模板，对象是类的实例。</p><p>​&#x3D;&#x3D;类：类是一种分类，一个类别，一个模板，它描述一类对象的行为和状态，是一组具有相同特性（属性）与行为（方法）的事物集合&#x3D;&#x3D;<br>​&#x3D;&#x3D;对象：是一个个性的产物，是一个个体的特征，是类的一个实例，有状态和行为&#x3D;&#x3D;</p><p><strong>类和对象的关系？</strong></p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>类里面有属性和方法，如果你要去调用该类的属性和方法，首相需要创建对象，通过对象可以重复的调用该类中的属性和方法，私有的除外。</p><p>对象能调用到什么属性和方法取决于这个对象属于哪个类(取决于该对象的类型)</p><p>优势：代码重用，提高开发效率</p></blockquote><h3 id="b-类的定义"><a href="#b-类的定义" class="headerlink" title="b.类的定义"></a>b.类的定义</h3><p>&#x3D;&#x3D;类是 <a href="http://c.biancheng.net/java/">Java</a> 中的一种重要的引用数据类型，也是组成 Java 程序的基本要素，因为所有的 Java 程序都是基于类的。&#x3D;&#x3D;</p><p>在 Java 中定义一个类，需要使用 class 关键字、一个自定义的类名和一对表示程序体的大括号。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">[public][abstract|final]class&lt;class_name&gt;[extends&lt;class_name&gt;][implements&lt;interface_name&gt;] &#123;    &#x2F;&#x2F; 定义属性部分    &lt;property_type&gt;&lt;property1&gt;;    &lt;property_type&gt;&lt;property2&gt;;    &lt;property_type&gt;&lt;property3&gt;;    …    &#x2F;&#x2F; 定义方法部分    function1();    function2();    function3();    …&#125;</code></pre><p>提示：上述语法中，中括号“[]”中的部分表示可以省略，竖线“|”表示“或关系”，例如 abstract|final，说明可以使用 abstract 或 final 关键字，但是两个关键字不能同时出现。</p><p>上述语法中各关键字的描述如下。</p><ul><li><code>public</code>：表示“共有”的意思。如果使用 public 修饰，则可以被其他类和程序访问。每个 Java 程序的主类都必须是 public 类，作为公共工具供其他类和程序使用的类应定义为 public 类。</li><li><code>abstract</code>：如果类被 abstract 修饰，则该类为抽象类，抽象类不能被实例化，但抽象类中可以有抽象方法（使用 abstract 修饰的方法）和具体方法（没有使用 abstract 修饰的方法）。继承该抽象类的所有子类都必须实现该抽象类中的所有抽象方法（除非子类也是抽象类）。</li><li><code>final</code>：如果类被 final 修饰，则不允许被继承。</li><li><code>class</code>：声明类的关键字。</li><li><code>class_name</code>：类的名称。</li><li><code>extends</code>：表示继承其他类。</li><li><code>implements</code>：表示实现某些接口。</li><li><code>property_type</code>：表示成员变量的类型。</li><li><code>property</code>：表示成员变量名称。</li><li><code>function()</code>：表示成员方法名称。</li></ul><p>Java 类名的命名规则：</p><ol><li>类名应该以下划线（_）或字母开头，最好以字母开头。</li><li>第一个字母最好大写，如果类名由多个单词组成，则每个单词的首字母最好都大写。</li><li>类名不能为 Java 中的关键字，例如 boolean、this、int 等。</li><li>类名不能包含任何嵌入的空格或点号以及除了下划线（_）和美元符号（$）字符之外的特殊字符。</li></ol><p>创建一个新的类，就是创建一个新的数据类型。实例化一个类，就是得到类的一个对象。因此，对象就是一组变量和相关方法的集合，其中变量表明对象的状态和属性，方法表明对象所具有的行为。定义一个类的步骤如下所述。</p><p>(1) 声明类。编写类的最外层框架，声明一个名称为 Person 的类。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Person &#123;    &#x2F;&#x2F; 类的主体&#125;</code></pre><p>(2) 编写类的属性。类中的数据和方法统称为类成员。其中，类的属性就是类的数据成员。通过在类的主体中定义变量来描述类所具有的特征（属性），这里声明的变量称为类的成员变量。</p><p>(3) 编写类的方法。类的方法描述了类所具有的行为，是类的方法成员。可以简单地把方法理解为独立完成某个功能的单元模块。</p><p>下面来定义一个简单的 Person 类。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Person &#123;    private String name;    &#x2F;&#x2F; 姓名    private int age;    &#x2F;&#x2F; 年龄    public void tell() &#123;           &#x2F;&#x2F; 定义说话的方法        System.out.println(name+&quot;今年&quot;+age+&quot;岁！&quot;);    &#125;&#125;</code></pre><h3 id="c-类的属性"><a href="#c-类的属性" class="headerlink" title="c.类的属性"></a>c.类的属性</h3><p>在 <a href="http://c.biancheng.net/java/">Java</a> 中类的成员变量定义了类的属性。例如，一个学生类中一般需要有姓名、性别和年龄等属性，这时就需要定义姓名、性别和年龄 3 个属性。声明成员变量的语法如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">[public|protected|private][static][final]&lt;type&gt;&lt;variable_name&gt;</code></pre><p>各参数的含义如下。</p><ul><li>public、protected、private：用于表示成员变量的访问权限。</li><li>static：表示该成员变量为类变量，也称为静态变量。</li><li>final：表示将该成员变量声明为常量，其值无法更改。</li><li>type：表示变量的类型。</li><li>variable_name：表示变量名称。</li></ul><p>&#x3D;&#x3D;可以在声明成员变量的同时对其进行初始化，如果声明成员变量时没有对其初始化，则系统会使用默认值初始化成员变量。&#x3D;&#x3D;</p><p>初始化的默认值如下：</p><ul><li>整数型（byte、short、int 和 long）的基本类型变量的默认值为 0。</li><li>单精度浮点型（float）的基本类型变量的默认值为 0.0f。</li><li>双精度浮点型（double）的基本类型变量的默认值为 0.0d。</li><li>字符型（char）的基本类型变量的默认值为 “\u0000”。</li><li>布尔型的基本类型变量的默认值为 false。</li><li>数组引用类型的变量的默认值为 null。如果创建了数组变量的实例，但没有显式地为每个元素赋值，则数组中的元素初始化值采用数组数据类型对应的默认值。</li></ul><p>定义类的成员变量的示例如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Student &#123;    public String name;    &#x2F;&#x2F; 姓名    final int sex &#x3D; 0;    &#x2F;&#x2F; 性别：0表示女孩，1表示男孩    private int age;    &#x2F;&#x2F; 年龄&#125;</code></pre><h3 id="d-成员方法"><a href="#d-成员方法" class="headerlink" title="d.成员方法"></a>d.成员方法</h3><p>声明成员方法可以定义类的行为，行为表示一个对象能够做的事情或者能够从一个对象取得的信息。类的各种功能操作都是用方法来实现的，属性只不过提供了相应的数据。一个完整的方法通常包括方法名称、方法主体、方法参数和方法返回值类型，成员方法一旦被定义，便可以在程序中多次调用，提高了编程效率。声明成员方法的语法格式如下：</p><pre class="line-numbers language-jav" data-language="jav"><code class="language-jav">public class Test &#123;    [public|private|protected][static]&lt;void|return_type&gt;&lt;method_name&gt;([paramList]) &#123;        &#x2F;&#x2F; 方法体    &#125;&#125;</code></pre><p>注意：上述语法中，中括号“[]”中的部分表示可以省略，竖线“|”表示“或”，例如 public|private，说明可以使用 public 或 private 关键字，但是两个关键字不能同时出现。</p><p>上述代码中一个方法包含 4 部分：方法的返回值、方法名称、方法的参数和方法体。其中 retum_type 是方法返回值的数据类型，数据类型可以是原始的数据类型，即常用的 8 种数据类型，也可以是一个引用数据类型，如一个类、接口和数组等。</p><p>除了这些，一个方法还可以没有返回值，即返回类型为 void，像 main() 方法。method_name 表示自定义的方法名称，方法的名称首先要遵循标识符的命名约定，除此之外，方法的名称第一个单词的第一个字母是小写，第二单词的第一个字母是大写，依此类推。</p><p>paramList 表示参数列表，这些变量都要有自己的数据类型，可以是原始数据类型，也可以是复杂数据类型，一个方法主要依靠参数来传递消息。方法主体是方法中执行功能操作的语句。其他各修饰符的含义如下。</p><ul><li>public、private、protected：表示成员方法的访问权限。</li><li>static：表示限定该成员方法为静态方法。</li><li>final：表示限定该成员方法不能被重写或重载。</li><li>abstract：表示限定该成员方法为抽象方法。抽象方法不提供具体的实现，并且所属类型必须为抽象类。</li></ul><h4 id="1-成员方法的返回值"><a href="#1-成员方法的返回值" class="headerlink" title="1.成员方法的返回值"></a>1.成员方法的返回值</h4><p>若方法有返回值，则在方法体中用 return 语句指明要返回的值，其格式如下所示。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">return 表达式   或   return (表达式)</code></pre><p>其中，表达式可以是常量、变量、对象等。表达式的数据类型必须与声明成员方法时给出的返回值类型一致。</p><h4 id="2-形参、实参及成员方法的调用"><a href="#2-形参、实参及成员方法的调用" class="headerlink" title="2.形参、实参及成员方法的调用"></a>2.形参、实参及成员方法的调用</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">methodName(&#123;paramList&#125;)</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">public int returnMin(int m,int n) &#123;    return Math.min(m,n);    &#x2F;&#x2F; m和n是形参&#125;public static void main(String[] args) &#123;    int x &#x3D; 50;    int y &#x3D; 100;    Test t &#x3D; new Test();    int i &#x3D; t.returnMin(x,y);    &#x2F;&#x2F; x和y是实参    System.out.println(i);&#125;</code></pre><p>方法的形参和实参具有以下特点：</p><ul><li>形参变量只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元。因此，形参只有在方法内部有效，方法调用结束返回主调方法后则不能再使用该形参变量。</li><li>实参可以是常量、变量、表达式、方法等，无论实参是何种类型的量，在进行方法调用时，它们都必须具有确定的值，以便把这些值传送给形参。因此应预先用赋值、输入等办法使实参获得确定值。</li><li>实参和形参在数量、类型和顺序上应严格一致，否则会发生“类型不匹配” 的错误。</li><li>方法调用中发生的数据传送是单向的，即只能把实参的值传送绐形参，而不能把形参的值反向地传送给实参。因此在方法调用过程中，形参的值发生改变，而实参中的值不会变化。</li></ul><p>在调用成员方法时应注意以下 4 点：</p><ol><li>对无参成员方法来说，是没有实际参数列表的（即没有 paramList），但方法名后的括号不能省略。</li><li>对带参数的成员方法来说，实参的个数、顺序以及它们的数据类型必须与形式参数的个数、顺序以及它们的数据类型保持一致，各个实参间用逗号分隔。实参名与形参名可以相同，也可以不同。</li><li>实参也可以是表达式，此时一定要注意使表达式的数据类型与形参的数据类型相同，或者使表达式的类型按 <a href="http://c.biancheng.net/java/">Java</a> 类型转换规则达到形参指明的数据类型。</li><li>实参变量对形参变量的数据传递是“值传递”，即只能由实参传递给形参，而不能由形参传递给实参。程序中执行到调用成员方法时，Java 把实参值复制到一个临时的存储区（栈）中，形参的任何修改都在栈中进行，当退出该成员方法时，Java 自动清除栈中的内容。</li></ol><h4 id="3-方法中的局部变量"><a href="#3-方法中的局部变量" class="headerlink" title="3.方法中的局部变量"></a>3.方法中的局部变量</h4><p>在方法体内可以定义本方法所使用的变量，这种变量是局部变量。它的生存期与作用域是在本方法内，也就是说，局部变量只能在本方法内有效或可见，离开本方法则这些变量将被自动释放。</p><p>在方法体内定义变量时，变量前不能加修饰符。局部变量在使用前必须明确赋值，否则编译时会出错。另外，在一个方法内部，可以在复合语句（把多个语句用括号<code>&#123;&#125;</code>括起来组成的一个语句称复合语句）中定义变量，这些变量只在复合语句中有效。</p><h3 id="e-this关键字"><a href="#e-this关键字" class="headerlink" title="e.this关键字"></a>e.this关键字</h3><p>​this 关键字是 <a href="http://c.biancheng.net/java/">Java</a> 常用的关键字，可用于任何实例方法内指向当前对象，也可指向对其调用当前方法的对象，或者在需要当前类型对象引用时使用。</p><p>this的两种使用方法</p><p>1.如果发生局部变量可以成员变量命名冲突时，可以通过this.成员变量名的方式区分实例变量和局部变量</p><p>2.一个构造方法中需要调用同一个类的另一个构造方法，可以通过this()的方式调用，但this()必须要书写在第一行</p><h4 id="this-属性名"><a href="#this-属性名" class="headerlink" title="this.属性名"></a>this.属性名</h4><p>通过this.成员变量名调用隐藏的成员变量</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Teacher &#123;    private String name;    &#x2F;&#x2F; 教师名称    private double salary;    &#x2F;&#x2F; 工资    private int age;    &#x2F;&#x2F; 年龄    public Teacher(String name,double salary,int age) &#123;    this.name &#x3D; name;    &#x2F;&#x2F; 设置教师名称    this.salary &#x3D; salary;    &#x2F;&#x2F; 设置教师工资    this.age &#x3D; age;    &#x2F;&#x2F; 设置教师年龄    &#125;&#125;</code></pre><p>this([参数列表])调用本一个类的另外一个构造方法</p><h4 id="this-方法名"><a href="#this-方法名" class="headerlink" title="this.方法名"></a>this.方法名</h4><h3 id="f-构造方法"><a href="#f-构造方法" class="headerlink" title="f.构造方法"></a>f.构造方法</h3><p>构造方法是类的一种特殊方法，用来初始化类的一个新的对象，在创建对象（new 运算符）之后自动调用。<a href="http://c.biancheng.net/java/">Java</a> 中的每个类都有一个默认的构造方法，并且可以有一个以上的构造方法。</p><p>Java 构造方法有以下特点：</p><ul><li>方法名必须与类名相同</li><li>可以有 0 个、1 个或多个参数</li><li>没有任何返回值，包括 void</li><li>默认返回类型就是对象类型本身</li><li>只能与 new 运算符结合使用</li></ul><p>构造方法主要有无参构造方法和有参构造方法两种</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MyClass &#123;    private int m;    &#x2F;&#x2F; 定义私有变量    MyClass() &#123;        &#x2F;&#x2F; 定义无参的构造方法        m &#x3D; 0;    &#125;    MyClass(int m) &#123;        &#x2F;&#x2F; 定义有参的构造方法        this.m &#x3D; m;    &#125;&#125;</code></pre><p>该示例定义了两个构造方法，分别是无参构造方法和有参构造方法。在一个类中定义多个具有不同参数的同名方法，这就是方法的重载。这两个构造方法的名称都与类名相同，均为 MyClass。在实例化该类时可以调用不同的构造方法进行初始化。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">注意：类的构造方法不是要求必须定义的。如果在类中没有定义任何一个构造方法，则 Java 会自动为该类生成一个默认的构造方法。默认的构造方法不包含任何参数，并且方法体为空。如果类中显式地定义了一个或多个构造方法，则 Java 不再提供默认构造方法。</code></pre><p>要在不同的条件下使用不同的初始化行为创建类的对象，这时候就需要在一个类中创建多个构造方法。下面通过一个示例来演示构造方法的使用。</p><h3 id="g-对象的创建"><a href="#g-对象的创建" class="headerlink" title="g.对象的创建"></a>g.对象的创建</h3><h4 id="1-直接通过对象操作属性赋值"><a href="#1-直接通过对象操作属性赋值" class="headerlink" title="**1.**直接通过对象操作属性赋值"></a>**1.**直接通过对象操作属性赋值</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">Car car1&#x3D;new Car(); car1.brand&#x3D;&quot;大众CC&quot;; car1.color&#x3D;&quot;黑色&quot;; car1.money&#x3D;-30;&#x2F;&#x2F;直接赋值，数据不安全 car1.carNumber&#x3D;&quot;赣Asv999&quot;;car1.carGo();</code></pre><h4 id="2-通过将属性封装，提高数据的安全性"><a href="#2-通过将属性封装，提高数据的安全性" class="headerlink" title="2.通过将属性封装，提高数据的安全性"></a>2.通过将属性封装，提高数据的安全性</h4><p>封装的定义：</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">将类中的某些信息(属性或方法)封装在类的内部，不允许外部程序直接访问，而是通过该类提供的方法来实现 对隐藏信息的操作</code></pre><p>步骤：1.将成员变量private私有化，将成员变量封装get、set方法分别来获取值和设置值</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">private String brand;    private String color;    private int price;    private String numberPlate;    public String getBrand() &#123;        return brand;    &#125;    public void setBrand(String brand) &#123;        this.brand &#x3D; brand;    &#125;    public String getColor() &#123;        return color;    &#125;    public void setColor(String color) &#123;        this.color &#x3D; color;    &#125;    public int getPrice() &#123;        return price;    &#125;    public void setPrice(int price) &#123;        &#x2F;&#x2F;将业务处理隐藏在方法内部，对象调用的时候无需知道内部具体实现的细节，这就是封装的概念         &#x2F;&#x2F;如果是负数就取用绝对值        this.price &#x3D; price;    &#125;    public String getNumberPlate() &#123;        return numberPlate;    &#125;    public void setNumberPlate(String numberPlate) &#123;        this.numberPlate &#x3D; numberPlate;    &#125;    public void showCarInfo()&#123;        System.out.println(&quot;汽车品牌:&quot;+brand+&quot;,汽车颜色&quot;+this.color+&quot;,汽车价格&quot;+this.price+&quot;,车牌号&quot;+this.numberPlate);    &#125;    public Car() &#123;    &#125;    public Car(String brand, String color, int price, String numberPlate) &#123;        this.brand &#x3D; brand;        this.color &#x3D; color;        this.price &#x3D; price;        this.numberPlate &#x3D; numberPlate;    &#125;</code></pre><h4 id="3-构造方法初始化对象赋值"><a href="#3-构造方法初始化对象赋值" class="headerlink" title="3.构造方法初始化对象赋值"></a>3.构造方法初始化对象赋值</h4><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">&#x2F;&#x2F;通过构造方法创建对象并且初始化对象，而且还可以对业务进行封装，数据更安全！ public Car(String brand, String color, int money, String carNumber) &#123;     this.brand &#x3D; brand;     this.color &#x3D; color;     if (money&lt;0) &#123;         this.money&#x3D; Math.abs(money);     &#125;else &#123;         this.money &#x3D; money;     &#125;this.carNumber &#x3D; carNumber; &#125;</code></pre><h3 id="h-static关键字"><a href="#h-static关键字" class="headerlink" title="h.static关键字"></a>h.static关键字</h3><p>在类中，使用 static 修饰符修饰的属性（成员变量）称为静态变量，也可以称为类变量，常量称为静态常量，方法称为静态方法或类方法，它们统称为静态成员，归整个类所有。</p><h4 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h4><p>类的成员变量可以分为以下两种：</p><ol><li>静态变量（或称为类变量），指被 static 修饰的成员变量。</li><li>实例变量，指没有被 static 修饰的成员变量</li></ol><p>静态变量与实例变量的区别如下：</p><p>1）静态变量</p><ul><li>运行时，Java 虚拟机只为静态变量分配一次内存，在加载类的过程中完成静态变量的内存分配。</li><li>在类的内部，可以在任何方法内直接访问静态变量。</li><li>在其他类中，可以通过类名访问该类中的静态变量。</li></ul><p>2）实例变量</p><ul><li>每创建一个实例，Java 虚拟机就会为实例变量分配一次内存。</li><li>在类的内部，可以在非静态方法中直接访问实例变量。</li><li>在本类的静态方法或其他类中则需要通过类的实例对象进行访问。</li></ul><p>静态变量在类中的作用如下：</p><ul><li>静态变量可以被类的所有实例共享，因此静态变量可以作为实例之间的共享数据，增加实例之间的交互性。</li><li>如果类的所有实例都包含一个相同的常量属性，则可以把这个属性定义为静态常量类型，从而节省内存空间。例如，在类中定义一个静态常量 PI。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static double PI &#x3D; 3.14159256;</code></pre><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>与成员变量类似，成员方法也可以分为以下两种：</p><ol><li>静态方法（或称为类方法），指被 static 修饰的成员方法。</li><li>实例方法，指没有被 static 修饰的成员方法。</li></ol><p>静态方法与实例方法的区别如下：</p><ul><li>静态方法不需要通过它所属的类的任何实例就可以被调用，因此在静态方法中不能使用 this 关键字，也不能直接访问所属类的实例变量和实例方法，但是可以直接访问所属类的静态变量和静态方法。另外，和 this 关键字一样，super 关键字也与类的特定实例相关，所以在静态方法中也不能使用 super 关键字。</li><li>在实例方法中可以直接访问所属类的静态变量、静态方法、实例变量和实例方法。</li></ul><h3 id="i-权限修饰符"><a href="#i-权限修饰符" class="headerlink" title="i.权限修饰符"></a>i.权限修饰符</h3><p>访问修饰符可以用于修饰属性和方法，用于定义属性和方法的访问权限</p><table><thead><tr><th></th><th>本类</th><th>本包</th><th>子类</th><th>其他包</th></tr></thead><tbody><tr><td>private(私有的)</td><td>OK</td><td>NO</td><td>NO</td><td>NO</td></tr><tr><td>default(默认不写)</td><td>OK</td><td>OK</td><td>NO</td><td>NO</td></tr><tr><td>protected(受保护的)</td><td>OK</td><td>OK</td><td>OK(有继承关系的其他包也可以用)</td><td>NO</td></tr><tr><td>public(公有的)</td><td>OK</td><td>OK</td><td>OK</td><td>OK</td></tr></tbody></table><p>&#x3D;&#x3D;权限从小到大: private&lt;默认不写&lt;protected&lt;public公有的&#x3D;&#x3D;</p><h2 id="C-特性"><a href="#C-特性" class="headerlink" title="C.特性"></a>C.特性</h2><h3 id="a-继承性"><a href="#a-继承性" class="headerlink" title="a.继承性"></a>a.继承性</h3><p>程序中的继承性是指子类拥有父类的全部特征和行为，这是类之间的一种关系。Java 只支持单继承。即只能有一个父类，但 Java 可以实现多个接口（接口类似于类，但接口的成员没有执行体。可以防止多继承所引起的冲突问题。</p><p>使用这种层次形的分类方式，是为了将多个类的通用属性和方法提取出来，放在它们的父类中，然后只需要在子类中各自定义自己独有的属性和方法，并以继承的形式在父类中获取它们的通用属性和方法即可。</p><h3 id="b-封装性"><a href="#b-封装性" class="headerlink" title="b.封装性"></a>b.封装性</h3><p>封装是将代码及其处理的数据绑定在一起的一种编程机制，该机制保证了程序和数据都不受外部干扰且不被误用。封装的目的在于保护信息，使用它的主要优点如下。</p><ul><li>保护类中的信息，它可以阻止在外部定义的代码随意访问内部代码和数据。</li><li>隐藏细节信息，一些不需要程序员修改和使用的信息，比如取款机中的键盘，用户只需要知道按哪个键实现什么操作就可以，至于它内部是如何运行的，用户不需要知道。</li><li>有助于建立各个系统之间的松耦合关系，提高系统的独立性。当一个系统的实现方式发生变化时，只要它的接口不变，就不会影响其他系统的使用。例如 U 盘，不管里面的存储方式怎么改变，只要 U 盘上的 USB 接口不变，就不会影响用户的正常操作。</li><li>提高软件的复用率，降低成本。每个系统都是一个相对独立的整体，可以在不同的环境中得到使用。例如，一个 U 盘可以在多台电脑上使用。</li></ul><p>Java 语言的基本封装单位是类。由于类的用途是封装复杂性，所以类的内部有隐藏实现复杂性的机制。Java 提供了私有和公有的访问模式，类的公有接口代表外部的用户应该知道或可以知道的每件东西，私有的方法数据只能通过该类的成员代码来访问，这就可以确保不会发生不希望的事情。</p><h3 id="c-多态性"><a href="#c-多态性" class="headerlink" title="c.多态性"></a>c.多态性</h3><p>面向对象的多态性，即“一个接口，多个方法”。多态性体现在父类中定义的属性和方法被子类继承后，可以具有不同的属性或表现方式。多态性允许一个接口被多个同类使用，弥补了单继承的不足。</p><h1 id="七：方法"><a href="#七：方法" class="headerlink" title="七：方法"></a>七：方法</h1><h2 id="A-定义-2"><a href="#A-定义-2" class="headerlink" title="A.定义"></a>A.定义</h2><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">把代码逻辑细节用方法封装起来，通过对象能够重复调用方法，实现代码复用，提高工作效率</code></pre><h2 id="B-方法种类"><a href="#B-方法种类" class="headerlink" title="B.方法种类"></a>B.方法种类</h2><p>返回值： 有返回值的、无返回值的</p><p>参数：有参的、无参数的</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">1.无返回值无参方法    2.无返回值有参方法    3.有返回值无参方法    4.有返回值有参方法</code></pre><h3 id="案例1："><a href="#案例1：" class="headerlink" title="案例1："></a>案例1：</h3><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">public void jisuan() &#123;     Scanner input&#x3D;new Scanner(System.in);    System.out.print(&quot;请输入语文成绩:&quot;);    int yuwen&#x3D;input.nextInt();     System.out.print(&quot;请输入数学成绩:&quot;);     int shuxue&#x3D;input.nextInt();     System.out.print(&quot;请输入英语成绩:&quot;);     int yingyu&#x3D;input.nextInt();     &#x2F;&#x2F;平均分     int avg&#x3D;(yuwen+shuxue+yingyu)&#x2F;3;     System.out.println(&quot;三门课程的平均分是:&quot;+avg); &#125;</code></pre><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">&#x2F;***需求： *在测试类调用计算的方法，得到语文、数学、英语的三门课程的平均分 **&#x2F; public class Test &#123;     public static void main(String[] args) &#123;         Admin admin&#x3D;new Admin();         &#x2F;&#x2F;调用无返回值无参数方法         admin.jisuan();     &#125; &#125;</code></pre><h3 id="案例2："><a href="#案例2：" class="headerlink" title="案例2："></a>案例2：</h3><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">public class Admin &#123;     &#x2F;**    * 有返回值无参数的方法     * @return     *&#x2F;     public int jisuan() &#123;         Scanner input&#x3D;new Scanner(System.in); System.out.print(&quot;请输入语文成绩:&quot;); int yuwen&#x3D;input.nextInt(); System.out.print(&quot;请输入数学成绩:&quot;); int shuxue&#x3D;input.nextInt(); System.out.print(&quot;请输入英语成绩:&quot;); int yingyu&#x3D;input.nextInt();         &#x2F;&#x2F;平均分         int avg&#x3D;(yuwen+shuxue+yingyu)&#x2F;3;         return avg;     &#125; &#125;public class Test &#123;     static void main(String[] args) &#123;         Admin admin&#x3D;new Admin();         &#x2F;&#x2F;调用有返回值无参方法         int avgScore&#x3D; admin.jisuan();         System.out.println(&quot;三门课程的平均分是:&quot;+avgScore);     &#125; &#125;</code></pre><h3 id="案例3："><a href="#案例3：" class="headerlink" title="案例3："></a>案例3：</h3><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">public class Admin &#123;     &#x2F;**    *    * 无返回值有参数方法     * 接受参数的这方叫形式参数(形参)     *&#x2F;     public void jisuan(int yuwen, int shuxue, int yingyu) &#123;        int avg&#x3D;(yuwen+shuxue+yingyu)&#x2F;3;         System.out.println(&quot;三门课程的平均分是:&quot;+avg);     &#125; &#125;&#x2F;*** 需求： 在测试类调用计算的方法，得到语文、数学、英语的三门课程的平均分 **&#x2F; public class Test &#123;    public static void main(String[] args) &#123;     Scanner input &#x3D; new Scanner(System.in);     System.out.print(&quot;请输入语文成绩:&quot;);     int yuwen &#x3D; input.nextInt();     System.out.print(&quot;请输入数学成绩:&quot;);     int shuxue &#x3D; input.nextInt();     System.out.print(&quot;请输入英语成绩:&quot;);     int yingyu &#x3D; input.nextInt();     Admin admin &#x3D; new Admin();     &#x2F;&#x2F;调用无返回值有参方法     &#x2F;&#x2F;具体传递值的叫实际参数(实参)    admin.jisuan(yuwen,shuxue,yingyu);        &#125; &#125;</code></pre><h2 id="C-值传递和引用类型传递【重要】"><a href="#C-值传递和引用类型传递【重要】" class="headerlink" title="C.值传递和引用类型传递【重要】"></a>C.值传递和引用类型传递【重要】</h2><h3 id="1-值类型案例"><a href="#1-值类型案例" class="headerlink" title="1.值类型案例"></a>1.值类型案例</h3><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">public class Admin &#123;     &#x2F;&#x2F;两值交换     public void change(int a, int b) &#123;         int c&#x3D;a; a&#x3D;b; b&#x3D;c;         System.out.println(&quot;交换：a:&quot;+a+&quot;,b:&quot;+b);    &#125; &#125;</code></pre><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">&#x2F;***值传递 * @author Administrator **&#x2F; public class Test &#123;     public static void main(String[] args) &#123;     int a&#x3D;5;     int b&#x3D;10;     Admin admin&#x3D;new Admin();     &#x2F;&#x2F;基本数据类型为参数，是值传递，是将值赋值一份给形参，当形参的值发生了改变，实参的值不变     admin.change(a,b);&#x2F;&#x2F;     System.out.println(&quot;a:&quot;+a+&quot;,b:&quot;+b);&#x2F;&#x2F;结果5,10 &#125;&#125;</code></pre><h3 id="2-引用类型传递"><a href="#2-引用类型传递" class="headerlink" title="2.引用类型传递"></a>2.引用类型传递</h3><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">public class Arrays &#123;     &#x2F;**    * static修饰的方法叫类方法或者叫静态方法     * 类方法属于类，可以通过类名直接调用，一般工具方法都是这样用比较方便     * @param score     *&#x2F;     public static void sortByDesc(int[] score) &#123;         for (int i &#x3D; 0; i &lt; score.length-1; i++) &#123;             for (int j &#x3D; 0; j &lt; score.length-i-1; j++) &#123;                if (score[j]&lt;score[j+1]) &#123;                     int temp&#x3D;score[j];                     score[j]&#x3D;score[j+1];                     score[j+1]&#x3D;temp;                 &#125;             &#125;         &#125;     &#125; &#125;</code></pre><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">&#x2F;*** 引用类型传递值 **&#x2F; public class Test &#123;     public static void main(String[] args) &#123;         int score[]&#x3D; &#123;3,45,6,67,1&#125;;        &#x2F;&#x2F; Arrays.sort(score);         &#x2F;&#x2F;数组、对象、集合、接口、类都是引用类型！         &#x2F;&#x2F;以数组为实参，是引用类型传递，是将score数组的地址复制了一份给形参         &#x2F;&#x2F;当形参指引到的数组的值发生了改变，因为实参和形参的地址是同一个，所以实参的值也会改变！         Arrays.sortByDesc(score);         for (int i : score) &#123;             System.out.print(&quot; &quot;+i);         &#125;    &#125; &#125;</code></pre><h1 id="八：方法重写和方法重载"><a href="#八：方法重写和方法重载" class="headerlink" title="八：方法重写和方法重载"></a>八：方法重写和方法重载</h1><h2 id="A-方法重载Overload【重要】"><a href="#A-方法重载Overload【重要】" class="headerlink" title="A.方法重载Overload【重要】"></a>A.方法重载Overload【重要】</h2><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">在同一个类中，多个方法名相同，但是参数的个数、类型、顺序不同，叫方法重载，与返回类型无关 方法重载各个重名的方法之间没有任何联系，只是叫同一个方法名而已，像构造方法必须和类名一致有时候需 要多个构造方法，所以叫构造方法重载。</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Student &#123;     String name;&#x2F;&#x2F;姓名     int age;&#x2F;&#x2F;年龄     char sex;&#x2F;&#x2F;性别     String studentNo;&#x2F;&#x2F;学号     double price;&#x2F;&#x2F;学费     public Student() &#123;&#125;     public Student(String name, int age, char sex) &#123;         super();         this.name &#x3D; name;         this.age &#x3D; age;         this.sex &#x3D; sex;     &#125;    &#x2F;&#x2F;构造方法的常见体现：构造方法重载     public Student(String name, int age, char sex, String studentNo, double price) &#123;        this.name &#x3D; name;         this.age &#x3D; age;         this.sex &#x3D; sex;         this.studentNo &#x3D; studentNo;        this.price &#x3D; price;     &#125;    public void study()&#123;         System.out.println(&quot;学生学习！&quot;);     &#125;    &#x2F;&#x2F;在一个类中，多个方法名相同，参数的个数、顺序、类型不同，叫方法重载，与返回类型无关     public void study(String name)&#123;         System.out.println(name+&quot;学生学习！&quot;);     &#125;    public static void main(String[] args) &#123;         &#x2F;&#x2F;具体调用本类中哪个方法具体看方法的参数！        new Student().study();         new Student().study(&quot;狗剩&quot;);        String str&#x3D;&quot;我是江西老表&quot;; &#x2F;&#x2F;字符串截取         String str2&#x3D;str.substring(2);         System.out.println(str2);         String str3&#x3D;str.substring(2,4);         System.out.println(str3);    &#125;&#125;</code></pre><h2 id="B-方法重写Override【重要】"><a href="#B-方法重写Override【重要】" class="headerlink" title="B.方法重写Override【重要】"></a>B.方法重写Override【重要】</h2><p>&#x3D;&#x3D;注意：我们所有的类都是继承于Object父类，&#x3D;&#x3D;父类也可以叫基类或者超类。子类继承于父类，当子类和父类的方法一致并且内容做了覆盖，叫做方法重写！</p><h3 id="1-重写object类的toString方法"><a href="#1-重写object类的toString方法" class="headerlink" title="1.重写object类的toString方法"></a>1.重写object类的toString方法</h3><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">public class Student &#123;     String name;&#x2F;&#x2F;姓名     int age;&#x2F;&#x2F;年龄     char sex;&#x2F;&#x2F;性别     String studentNo;&#x2F;&#x2F;学号     double price;&#x2F;&#x2F;学费     &#x2F;&#x2F;构造方法的常见体现：构造方法重载     public Student(String name, int age, char sex, String studentNo, double price) &#123;        this.name &#x3D; name;         this.age &#x3D; age;         this.sex &#x3D; sex;         this.studentNo &#x3D; studentNo;         this.price &#x3D; price;     &#125;    &#x2F;&#x2F;重写了Object类的toString方法     &#x2F;&#x2F;子类如果和父类方法一致，只是具体实现内容不一样，叫方法重写或者叫方法覆盖     &#x2F;&#x2F;优势：扩展性更强！     @Override     public String toString() &#123;         return &quot;Student属性:[name&#x3D;&quot; + name + &quot;, age&#x3D;&quot; + age + &quot;, sex&#x3D;&quot; + sex + &quot;, studentNo&#x3D;&quot; + studentNo + &quot;, price&#x3D;&quot; + price + &quot;]&quot;;     &#125; &#125;</code></pre><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">public class Test &#123;     public static void main(String[] args) &#123;         Student stu2&#x3D;new Student(&quot;张三&quot;,21,&#39;男&#39;,&quot;S0001&quot;,1000);         System.out.println(stu2.toString());     &#125; &#125;</code></pre><h3 id="2-重写Object类的equals方法"><a href="#2-重写Object类的equals方法" class="headerlink" title="2.重写Object类的equals方法"></a>2.重写Object类的equals方法</h3><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">public class Teacher &#123;     String name;&#x2F;&#x2F;称呼     int code;&#x2F;&#x2F;身份证号码    public Teacher(String name, int code) &#123;         super();         this.name &#x3D; name;         this.code &#x3D; code;     &#125;    &#x2F;**    * 重写Object父类的equals方法，如果编号一致就返回true     *&#x2F;     @Override     public boolean equals(Object obj) &#123;         &#x2F;&#x2F;如果两个对象地址一致，返回true         if (this&#x3D;&#x3D;obj) &#123; return true; &#125;        &#x2F;&#x2F;将父类类型用子类类型接收，需要向下转型         Teacher t&#x3D;(Teacher) obj;         if (this.code&#x3D;&#x3D;t.code)         &#123;             &#x2F;&#x2F;判断两个对象的属性code员工编号一致，那么就返回true             return true;         &#125;else &#123; return false; &#125;     &#125; &#125;</code></pre><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">public class Test &#123;     public static void main(String[] args) &#123;         Teacher teacher1&#x3D;new Teacher(&quot;棋哥&quot;,10001);         Teacher teacher2&#x3D;new Teacher(&quot;老彭&quot;,10001); &#x2F;&#x2F;System.out.println(teacher1.equals(teacher2));&#x2F;&#x2F;false         &#x2F;&#x2F;需求：根据身份证编号来判断这两个对象是同一个人！         &#x2F;&#x2F;Object类的equals方法底层是比较地址，显然不能满足我们的需求，如何解决？-&gt;重写Object的 equals方法         System.out.println(teacher1.equals(teacher2));&#x2F;&#x2F;true     &#125;    &#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;JavaSE基础&lt;/p&gt;</summary>
    
    
    
    <category term="JavaSE" scheme="https://umrlll.github.io/categories/JavaSE/"/>
    
    
    <category term="Java" scheme="https://umrlll.github.io/tags/Java/"/>
    
    <category term="基础" scheme="https://umrlll.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
